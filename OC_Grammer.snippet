----------------------------------华丽的分割线--------------------------- 
  1. 返回值代表程序的结束状态.
     0 代表正常结束 非0代表非正常结束.
 
 
  2. 参数
 
     argv数组的第0个元素的值 是这个正在运行的程序的路径.
     argc代表的是数组的长度.
 
 
     我们在运行程序的时候,可以将程序放在终端运行.在终端运行的时候可以为这个程序传入一些数据
     程序名 数据....
 
 
 
     
  3. 你要清楚一件事情.
 
     我们写的程序可以在终端中运行. 运行的时候可以为程序传递一些数据.
     传递的方式:
 
     程序名 数据1 数据2 数据3 .....
 
 
     在程序的内部如何拿到.
 
     argc代表用户传递的数据的个数.
     argv数组中每1个元素存储的就是用户传递过来的数据.
 
     第0个元素是程序的路径.
 
----------------------------------华丽的分割线--------------------------- 
1. OC相对于C
     a. 在C的击基础之上新增了1小部分面向对象的语法.
     b. 将C的复杂的、繁琐的、可恶的语法封装的更为简单.
 
     c. OC完全兼容C语言.
 
 
  2. OC程序的源文件的后缀名是.m   m代表message 代表OC中最重要的1个机制  消息机制.
     C程序的源文件的后缀名.c
 
 
  3. main函数仍然是OC程序的入口和出口.
 
     int类型的返回值 代表程序的结束状态.
     main函数的参数: 仍然可以接收用户在运行程序的时候传递数据给程序.
                   参数也可以不要 。
 
 
  4. #import指令.
 
     1).以#号开头,是1个预处理指令.
 
     2).作用:  是#inlcude指令的增强版. 将文件的内容在预编译的时候拷贝写指令的地方.
 
     3).增强:  同1个文件无论#import多少次,只会包含1次.
 
              如果#include指令要实现这个效果 就必须要配合条件编译指令来实现.
              而#import指令只需要直接包含就可以 其他什么都不用作.
 
     4).简要原理: #import指令在包含文件的时候,底层会先判断这个文件是否被包含  如果被包含就会略过 否则才会包含.
 
 
 
  5. 框架
     1). 是1个功能集  苹果或者第三方事先将一些程序在开发程序的时候经常要用到的功能事先写好.把这些功能封装在1个1个的类或者函数之中.
         这些函数和类的集合就叫做框架.
 
         有点像C语言的函数库.
 
 
     2). Foundation框架.
 
 
         Foundation: 基础 基本. 这个框架中提供了一些最基础的功能  输入和输出. 一些数据类型.
 
 
         Foundation.h的路径:
 
         /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/System/Library/Frameworks/Foundation.framework/Versions/C/Headers/Foundation.h
 
 
         Foundation。h这个文件中包含了Foundation框架中的其他的所有的头文件.
         所以,我们只要包含Foundation.h 就相当于包含了Foundation框架中所有的头文件.
         那么Foundation框架中的所有的函数和类就可以直接使用.
 
 
 
  6. @autoreleasepool是自动释放池.
 
     你只需要知道这个是1个自动释放池.
 
     你可以将代码写在自动释放池之中 或者干脆把这个自动释放池删除 不会有任何影响.
 
 
 
  7. NSLog函数.
 
    1). 作用: 是printf函数的增强版. 向控制台输出信息.
 
    2). 语法: 
             NSLog(@"格式控制字符串",变量列表);
 
        最简单的语法:
             NSLog(@"要输出的信息");
 
 
    3). 增强:
        a. 输出一些调试相关信息.
           2020-07-01 12:40:52.628 Day01-OC基础语法[784:210576] Hello,World!
 
           执行这段代码的时间.
           程序的名称.
           进程编号.
           线程编号.
           输出的信息.
 
 
        b. 会自动换行.在输出完信息之后 会自动换行.
 
 
        c. OC中其实新增了一些数据类型. NSLog函数不仅仅可以输出C数据类型变量的值还可以输出OC新增的数据类型的变的值.
 
 
    4).用法和printf函数差不多. 一样可以输出变的值 并且占位符和用法都一样
 
 
    5).使用注意:
       a. NSLog函数的第1个参数前面必须要加1个@符号.
 
       b. 如果手贱在字符串的末尾加了1个'\n'代表换行 那么函数的自动换行功能就会失效.
 
 
 
 
   ------
   忘记#include 用#import
   忘记printf 用NSLog
 
 
 
 8. 字符串
 
    1). C语言的字符串的存储方式
 
        a. 使用字符数组存储
 
        b. 使用字符指针
 
 
    2). OC中设计了1个更为好用的用来存储字符串的1个类型.  NSString
 
 
        NSString 类型的指针变量 专门用来存储OC字符串的地址.
 
 
    3). OC的字符串常量必须要使用1个前缀@符号.
 
        "jack" 这是1个C语言的字符串.
 
        @"jack" 这是1个OC的字符串常量.
 
 
        NSString类型的指针变量,只能存储OC字符串的地址.
 
        NSString *str = @"jack";
 
 
    4).总结
 
       a. 在OC中专门设计了1个NSString类型来存储字符串.
       b. 字符串分为C字符串和OC字符串.
 
          字符串如果没有@前缀 那么这个字符串常量就是1个C字符串.
          字符串如果有@前缀  那么这个字符串常量就是OC字符串.
 
          @"jack"
          "rose"
 
          所以,OC字符串常量的前面必须要加1个@符号.
 
 
       c. NSString类型的指针变量 只能存储 OC字符串.
 
          NSString *str = @"jack";
 
 
    5). 注意
      
       1). NSLog函数的第1个参数是1个OC字符串,所以NSLog函数的第1个实参应该以@符号开头.
 
 
       2). 如果要使用NSLog函数输出OC字符串的值,那么使用占位符%@
 
 
 
 9. NS前缀.
 
 
    NextStep  ---> Cocoa ---> Foundation框架之中.
 
 
 10. @符号
 
     1). 将C字符串转换为OC字符串.
 
        "jack"   @"jack"
 
 
     2). OC中的绝大部分的关键字都是以@符号开头.
 
 
 
 11. 注释:
 
     和C语言的注释一模一样.分为单行注释和多行注释.
 
 
 
 12. 函数的定义和调用.
 
     与C语言的函数的定义和调用是一样的.



----------------------------------华丽的分割线--------------------------- 
1. OC程序的编译、连接、执行.
 
     1). 在.m文件中写上符合OC语法规范的源代码.
 
 
     2). 使用编译器将源代码编译为目标文件.'
 
 
          cc -c xx.m
 
          a. 预处理
          b. 检查语法
          c. 编译.
 
 
     3).链接
        cc xx.o
 
        如果程序中使用到了框架中的函数或者类.那么在链接的时候,就必须要告诉编译器
        去那1个框架中找这个函数或者类.
 
 
        cc xx.o -framework 框架名称.
 
        cc main.o - framework Foundation
 
 
        程序中用到了那1个框架中的功能 那么就再这个地方告诉编译器.
 
 
     4) 链接成功以后 就会生成1个a.out可执行文件 执行就可以了.
 
 
 
 2、 我们1点击运行按钮 所有的事情Xcode就帮助我们自动的做了.
 
 
 
 3.  OC程序和C程序各个阶段的后缀名对比
 
 
     源文件        目标文件      可执行文件
 
 C    .c           .o          .out
 OC   .m           .o          .out



----------------------------------华丽的分割线--------------------------- 
1. OC中的数据类型.
 
     1). OC中支持C语言中的所有的数据类型.
 
          a. 基本数据类型
             int double float char
 
          b. 构造类型 
             数组 结构体  枚举
 
          c. 指针类型
             int *p1;
 
          d. 空类型
             void
 
          e. typedef自定义类型.
 
 
     2). BOOL类型.
 
         1). 可以存储YES或者NO中的任意1个数据.
 
         2). 一般情况下BOOL类型的变量用来存储条件表达式的结果.如果条件表达式成立 那么结果就是YES
             如果条件表达式不成立 结果过就是NO
 
 
         3). BOOL的本质.
 
             typedef signed char BOOL; 
             实际上BOOL类型的变量 是1个有符号的char变量.
 
 
             #define YES ((BOOL)1)
             #define NO  ((BOOL)0)
 
             YES  实际上就是 1
             NO  实际上就是 0
 
     3). Boolean
 
         a.Boolean类型的变量可以存储true或者flase
         b.一般情况下Boolean类型的变量用来存储条件表达式的结果.如果条件表达式成立 那么结果就是true
            如果条件表达式不成立 结果过就是false
 
 
         c. 本质
            typedef unsigned char                   Boolean;
 
             #define true 1
             #define false 0
             
 
 
      4). class 类型. 类.
 
      5). id类型 万能指针.
 
 
      6). nil 与NULL差不多.
 
      7). SEL 方法选择器.
 
      8). block 代码段.



----------------------------------华丽的分割线--------------------------- 
1. OC是在C的基础之上.
     a. 将C复杂的繁琐的恶心的语法封装的更为简单.
        
         #import 
         NSLog
         NSString
         .......
 
     b. 在C语言的基础之上新增了一小部分的面向对象的语法.
 
 
 
  2. 实现需求之一:
     要把大象放进冰箱应该怎么办?
 
      a. 打开冰箱门.
      b. 把大象放进去
      c. 把冰箱门关上.
 
 
      有没有更好的方式:
 
      找1个冰箱 自己开门 自己把大象拉进去 自己关门.
 
 
 
      买电脑的需求的实现方式
 
      1). 根据自己的需求和预算确定买的电脑型号的.
 
          10000  iOS开发.
 
 
      2). 在网上查找资料 确定型号.
 
          rMMP 9288
 
      3). 去到岗顶.
 
 
      4). 找到Apple专门店.
 
 
      5). 砍价 成交.
 
      6). 愉快的回家了.
 
 
     -----------
      有可能会出的问题. 就是被骗.........
 
 
     避免被骗得方式: 找1个电脑高手.
 
 
     买电脑的两种方式:
     1). 每1件事情都是我们亲自去做. 这样不好  你不是专业的 所以你无法取做到专业.\
 
         强调的是过程,强调的是步骤. 我是主角. 我是1个彻头彻尾的执行者
 
 
 
     2). 找1个电脑高手. 我只需要带钱 其他事情电脑高手帮助我做.
 
         强调的是: 电脑高手. 我就是1个扬眉吐气的指挥者.
 
 
    同1件事情我们有两种不同的解决思路.
 
    如果解决1件事情的时候,每1件事情都是我们亲自去一步步实现 那么这种解决问题的思路叫做面向过程的解决思路.
    如果解决1件事情的时候,自己不去亲自做,而是找1个专门做这件事情的人来帮助我们做.这样解决问题的思路我们就叫做面向对象的解决思路.
 
 
 
    面向过程与面向对象是解决同1个问题的不同的思路.
 
 
 3. 代码世界的面向过程与面向对象.
 
    1). 面向过程.
 
    在遇到1个需求的时候,实现这个需求的每1个步骤 都是自己写代码亲自的去一步步的实现. 这样的解决问题的方式我们就叫做面向过程的方式.
    
 
    2). 面向对象.
 
        在遇到1个需求的时候,不要亲自去实现 而是找1个专门做这件事情的人来帮助我们搞定. 这样的解决问题的方式就叫做面向对象的解决方式.
 
 
 4. 面向对象和面向过程优缺点分析.
 
     C语言是1门面向过程的语言. 有功能的概念 但是没有人的概念.
     OC语言是1门面向对象的语言.
 
 
     面向过程的解决问题的缺点: 后期的维护和修改不方便.
     面向对象的解决问题的优点: 后期的维护和修改十分方便.
 
 
     使用面向对象设计我们的程序,可以让我们的程序在后期的维护和修改当中更加的方便和快捷.
 
 
 
 
 5. 如何使用面向对象来设计程序呢?
 
 
    当你遇到1个需求的时候. 不要亲自去实现. 
    1). 先看看有没有现成的人是专门做这件事情的. 框架. 如果有直接使用
 
    2). 如果没有.就自己造出1个拥有这样的功能的人. 那么造出来的这个人可以多次使用的.



----------------------------------华丽的分割线--------------------------- 
1. 什么是对象?
    
     对象是现实生活中的1个具体存在. 看得见、摸的着.拿过来就可以直接使用.
 
 
  2. 什么是类.
 
     物以类聚 人以群分.
 
     类是对一群具有相同特征或者行为的事物的1个统称. 抽象的. 不能直接使用.
 
     如果非要使用类的话呢?只能去找到这1类事物中的1个具体存在,然后使用这个具体存在.
 
 
  3. 案例
 
     食物.
     水果.
     苹果.
     烟台苹果
     小东早上吃的那1个颗苹果.
 
 
     交通工具.
     车
     汽车
     奔驰汽车.
     奔驰汽车CLS350
 
 ----------------------------------
 1. 类和对象之间的关系.
 
 
    类是模板.类的对象是根据这个模板创建出来的.
    类模板中有什么,对象中就有什么 绝不可能多 也绝不可能少.
 
 
    类是制造月饼的模子. 模子不可以吃 所以类不能直接使用.
    对象是根据模子制造出来的月饼, 模子上有什么 月饼上就有什么 不会多也不会少.
    月饼可以吃 所以对象可以使用.
 
 
 
 
 2.如何设计1个类.
 
   类的作用: 用来描述一群具有相同特征和行为的事物的.
 
 
   设计类的三要素.
   
   -> 类的名字. 你要描述的这类事物叫什么名字.
    
   -> 这类事物具有的相同的特征. 这类事物拥有什么
 
   -> 这类事物具有的共同的行为. 这类事物会做什么.
 
 
 
 3. 如何找到类.
 
    名词提炼法: 分析整个业务流程,分析出现了哪些名词. 这些名词就是你要找到的类.
 
 
    3辆坦克发射了6枚炮弹打中了3架飞机.
 
 
    坦克类
        特征: 型号.大小.颜色.重量. 材质. 射程.
        行为: 行驶. 发射.
 
 
    炮弹类
        特征: 型号.大小.威力.颜色. 重量.
        行为: 飞 爆炸
 
 
 
    飞机类
        特征: 型号 作为数量.。。。。。
        行为: 飞 爆炸.
 
 
 
 
    小明在公交车上牵着1只叼着热狗的狗.;
 
    人类: 
       姓名 性别....
       搭公交. 遛狗.
 
    公交车
       品牌 价格 颜色..
 
        行驶.
 
 
    热狗
       大小 颜色 味道 温度.
       散发味道.
 
 
    狗
        颜色  品质......
        吃热狗....



----------------------------------华丽的分割线--------------------------- 
 1. 请问是先有类还是先有对象?
 
     从现实的角度 一定是先有对象再有类.
     从代码的角度 一定是先有类再游对象.
 
 
  2. 再一次确认类的作用: 描述1群具有相同特征和行为的事物的.
 
 
  3. 如何定义类.
 
     1).类的三要素.
 
 
     2).定义类的语法
 
        a. 位置. 直接写在源文件之中 不要写在main函数之中.
 
        b. 类的定义分为两个部分.
           -> 类的声明
 
           @inteface 类名 : NSObject
           {
                这类事物具有的共同的特征.将他们定义为变量.
           }
           功能就是1个方法.将方法的声明写在这里.
           @end
           -> 类的实现
 
           @implementation 类名
           将方法的实现写在这里.
           @end
 
 
 
      3).几点注意
 
         a. 类必须要有声明和实现
         b. 类名用你描述的事物的名称来命名就可以了.
            类名的每1个单词的首字母必须要以大写开头.
 
         c. NSObject是神马意思 不用惯 照写就可以了 。
         d. 用来表示着类事物的共同的特征的变量必须要定义在@interface的大括弧之中.
         e. 定义在大括弧之中用来表示着类事物的共同的特征的变量我们叫做.
            属性 成员变量 实例变量 字段.......
 
         f. 为类定义属性的时候,属性的名词必须要以_开头 下划线开头.
 
 
        语法是固定的.
 
         @interface 类名 : NSObect
         {
             这类事物具有的共同的特征定义为变量.
             数据类型 变量名1;
             数据类型 变量名2;
             .........
         }
 
         @end
 
 
         @implementation 类名
 
         @end
 
 4. 类的定义.
 
    1). 类的作用.
 
    2). 类的三要素.
 
    3). 类的定义.
 
 
 
 
 5. 类是无法直接使用的. 如果非要使用这个类的话,就必须要先找到这个类中的1个具体存在.
    再使用这个对象
 
 
    类和对象的关系: 类中有的东西 这个类的对象也有 不会多少也不会少. 对象就可以使用.
    这个时候我们就可以使用对象里面东西..
 
 
    如何创建1个类的对象呢?
 
    语法:  类名 *对象名 = [类名 new];
 
          Person *p1 = [Person new];
 
          根据Person这个类的模板,创建了1个对象名字叫做p1.
          p1对象的特点:
          -> 可以直接使用.
          -> 类中定义的东西 这个对象中也有 不会多也不会少.
 
 
 
 
 6. 如何使用对象;
 
 
    如何访问对象的属性:
 
    1). 默认情况下,对象的属性是不允许被外界直接访问的.
 
        如果允许对象的属性可以被外界访问,那么就再声明属性的是加1个@public关键字.
 
 
    2). 访问对象的属性的方式
 
        对象名->属性名 = 值;
        对象名->属性名;
 
 
        (*对象名).属性名;
 
        平时使用的时候,使用->



----------------------------------华丽的分割线--------------------------- 
 1.定义1个类.
 
    分为类的声明和实现
 
    @interface 类名 : NSObject
    {
        属性 属性表示类的特征.
    }
    方法的声明; 方法表示类的功能.
    @end
 
 
    @implementation 类名
    方法的实现;
    @end
 
 
  2.1类事物不仅具有相同的特征还具有相同的行为.
 
    行为就是1个功能. C语言中使用函数来表示1个功能.
    OC的类具有的行为,我们使用方法来表示..
 
 
    方法和函数都表示1个功能.
 
 
 
 
  3. 无参数的方法.
 
 
     1). 声明
 
         a. 位置: 在@interface的大括弧的外面.
 
         b. 语法: 
            - (返回值类型)方法名称;
            - (void)run;
            表示声明了1个无返回值并且无参数的方法 方法名字叫做run
 
 
     2). 实现
 
         a.位置: 在@implementation之中实现
 
         b.实现的语法:
 
           将方法的声明拷贝到@implementation之中.去掉分号 追加大括弧1对 将方法实现的代码写在大括弧之中.
 
 
     3).调用
 
         a. 方法是无法直接调用的.因为类是不能直接使用的.必须要先创建对象.
            那么这个对象中就有类中的属性和方法了 就可以调用对象的方法了.
 
         b. 调用对象的方法.
    
 
             [对象名 方法名];
 
 
 4.带1个参数的方法.
 
    1). 声明
 
        a.位置: 在@interface的大括弧的外面.
 
        b.语法:
          - (返回值类型)方法名称:(参数类型)形参名称;
          - (void)eat:(NSString *)foodName;
 
          定义了1个方法 这个方法没有返回值.
          这个方法的名字叫做eat:
          这个方法有1个参数,类型是NSString *类型的 参数的名字叫做foodName
 
 
 
         - (void)eat:(NSString *)foodName;
 
         void eat(NSString *foodName);
 
 
 
 
 
 
    2). 实现
 
        a.位置: 在@implementation之中实现
 
        b.语法: 将方法的声明拷贝到@implementation之中.去掉分号 追加大括弧1对 将方法实现的代码写在大括弧之中.
 
 
    3). 调用
 
         a. 方法是无法直接调用的.因为类是不能直接使用的.必须要先创建对象.
         那么这个对象中就有类中的属性和方法了 就可以调用对象的方法了.
 
 
         b. 调用语法:
 
            [对象名 方法名:实参];
 
         
 
     方法头中的数据类型都要用1个小括弧括起来.
 
     - (返回值类型)方法名称:(参数类型)参数名称;
 
 
 
 5.带多个参数的方法.
 
   1) 声明
 
       a.位置: 在@interface的大括弧的外面.
    
       b. 语法:
 
        - (返回值类型)方法名称:(参数类型)形参名称1 :(参数类型)参数名称2 :(参数类型)参数名称3;
 
        - (int)sum:(int)num1 :(int)num2;
 
        表示声明了1个方法 这个方法的返回值类型是int类型的.
        方法的名称叫做 sum: :
        有两个参数 参数类型都是int类型 参数名称叫做num1 num2
 
 
 
    2).实现.
       
        a. 位置: 在@implementation之中实现
    
        b. 实现的语法: 将方法的声明拷贝到@implementation之中.去掉分号 追加大括弧1对 将方法实现的代码写在大括弧之中.
 
 
 
    3).调用:
 
         a. 方法是无法直接调用的.因为类是不能直接使用的.必须要先创建对象.
         那么这个对象中就有类中的属性和方法了 就可以调用对象的方法了.

 
 
         b. 调用带多个参数的语法
 
         [对象名 方法名:实参1 :实参2 :实参3];
         
 
 
 
 6. 带参数的方法声明的规范:
 
 
    1). 如果方法只有1个参数. 要求最好这个方法的名字叫做 xxxWith:
        xxxWithxxx
 
        eatWith:
        eatWithFood:
 
        这样写的话,那么调用方法的时候看起来就像是1条完整的语句. 提高了我们代码的阅读性.
 
        遵守的规范: 就是让我们的方法调用的时候看起来像1条完整的语句.
 
 
 
    2).如果方法有多个参数 建议这个方法名称:
 
       方法名With:(参数类型)参数名称 and:(参数类型)参数名称 and:(参数类型)参数名称;
       - (int)sumWith:(int)num1 and:(int)num2;
 
 
        sumWith: and:
 
 
      更详细的写法
      方法名With参数1:(参数类型)参数名称 and参数2:(参数类型)参数名称 and参数3:(参数类型)参数名称;



----------------------------------华丽的分割线--------------------------- 
1. 同1个类可以创建无数个对象.
 
 
  2. 同1个类的多个对象之间毫无关系.
     虽然他们拥有相同的属性和方法.
 
     属性的值是不会相互影响的
 
 
  3. 在方法的实现中,可以直接访问属性.
 
     在方法中访问的属性是谁的属性呢?
 
     这个方法是通过那1个对象来调用的.那么方法中的直接访问的属性就是那1个对象的.
 
 
  4. 案例.
 
     定义1个类,叫做Student 
 
     属性: 体重.
 
     方法: 跑步: 每跑1次 这个学生对象的体重-0.5;
          吃饭: 每吃1次饭 这个学生对象的体重 +0.7



----------------------------------华丽的分割线--------------------------- 
1. OC在C的基础之上
    a. 增加了面向对象的语法
    b. 将C语言中复杂的繁琐的语法封装的更为简单.
 
 
 2. 更为简单.
 
    a. #import 指令
       同1个文件无论#import多少次. 最终都只会包含1次 不会出现重复包含的情况.
 
    b. NSLog函数.
       a. 自动换行.
       b. 会输出一些其他的调试信息.
 
 
    c. NSString
       a. OC字符串常量和C的字符串常量.
 
          字符串常量前面必须要加1个前缀@ 这才是OC的字符串.
           NSString只能存储OC字符串常量.
 
         NSString *str = @"jack";
 
    d. 数据类型.
 
       BOOL   YES  NO
       Boolean true false
 
 
       class 
       id
       nil
       SEL
       block
 
 
 3.面向对象的语法
 
    1). 面向过程 面向对象.
 
    2). 面向对象的最大的优点.
 
    3). 类和对象
 
    4). 类和对象之间的关系.
 
    5). 设计类的三要素
 
        类名 特征 行为.
 
    6). 名词提炼法
 
 
 4. 类和对象
 
     1).定义类
 
        a. 位置: 
        b. 语法
 
           类的声明
           @interface 类名 : NSObject
           {
              属性
           }
           方法的声明
           @end
 
           类的实现
 
           @implementation 类名
 
           方法的实现
           @end
 
 
      2).方法的声明和实现.
          
         a. 声明的位置: 在@interface的大括弧的外面.
         b. 实现的位置: 在@implementation之中.
 
         c. 实现的语法: 将方法的声明拷贝到@implementation之中 去掉分号 追加大括弧 将方法的实现代码写在大括弧之中就可以了.
 
 
         无参数的方法的声明:
 
         - (返回值类型)方法名;
 
         1个参数的方法的声明.
         - (返回值类型)方法名WithXXX:(参数类型)参数名;
 
         多个参数的方法.
 
         - (void)方法名WithXXX:(参数类型)参数名 andXXXX:(参数类型)参数名;
 
 
 5. 对象的创建.
 
     类名 *对象名 = [类名 new];
 
 
     Person *p1 = [Person new];
 
     对象的特点: 对象拥有类中定义的所有的成员.
               对象中的成员可以直接访问.
 
 
 6. 访问对象.
 
     
 
 
 7. 同1个类可以创建N个对象 并且这N个对象毫无关系.
 
    在方法中直接访问属性 访问的就是当前对象的属性 



----------------------------------华丽的分割线--------------------------- 
1. 内存中的五大区域.
 
     栈 存储局部变量.
     堆 程序员手动申请的字节空间 malloc calloc realloc函数.
     BSS段 存储未被初始化的全局变量 静态变量.
     数据段(常量区) 存储已被初始化的全局 静态变量 常量数据.
     代码段 存储代码. 存储程序的代码.
 
 
 
  2. 类加载.
 
     1). 在创建对象的时候 肯定是需要访问类的.
 
     2). 声明1个类的指针变量也会访问类的.
 
 
     在程序运行期间 当某个类第1次被访问到的时候. 会将这个类存储到内存中的代码段区域.这个过程叫做类加载.
 
     只有类在第1次被访问的时候,才会做类加载.
     一旦类被加载到代码段以后. 直到程序结束的时候才会被释放.
 
 
  3. 对象在内存中究竟是如何存储的.
 
     假设下面这个写在函数之中.
     Person *p1 = [Person new];
 
 
    1). Person *p1; 会在栈内存中申请1块空间. 在栈内存中声明1个Person类型的指针变量p1。
                    p1是1个指针变量.  那么只能存储地址.
 
 
    2). [Person new]; 真正在内存中创建对象的其实是这句代码.
 
                  new做的事情
 
                  a. 在堆内存中申请1块合适大小的空间.
                  b. 在这个空间中根据类的模板创建对象.
 
                     类模板中定义了什么属性.就把这些属性依次的声明在对象之中.
                     对象中还有另外1个属性 叫做isa 是1个指针. 指向对象所属的类在代码段中的地址.
 
                  c. 初始化对象的属性
                     如果属性的类型是基本数据类型 那么就赋值为0
                     如果属性的类型是C语言的指针类型 那么就赋值为NULL
                     如果属性的类型是OC的类指针类型 那么就赋值为nil
 
                  d. 返回对象的地址.
 
    3). 注意
 
         a. 对象中只有属性,而没有方法. 自己类的属性外加1个isa指针指向代码段中的类.
 
         b. 如何访问对象的属性
            指针名->属性名;
 
            根据指针 找到指针指向的对象 再找到对象中的属性来访问.
 
         c. 如何调用方法.
            [指针名 方法名];
 
            先根据指针名找到对象,对象发现要调用方法 再根据对象的isa指针找到类.
            然后调用类里的方法.
 
 
 
 
  4. 为什么不把方法存储在对象之中?
 
     因为每1个对象的方法的代码实现都是一模一样的  没有必要为每1个对象都保存1个方法 这样的话就太浪费空间了.
     既然都一样 那么就只保持1份.
 
 
 
  5. 对象的属性的默认值.
 
     如果我们创建1个对象,没有为对象的属性赋值. 那么这个对象的属性是有值的.
 
     如果属性的类型是基本数据类型 默认值是0
     如果属性的类型是C指针类型 那么默认值是NULL
     如果属性的类型是OC指针类型  那么默认值是nil



----------------------------------华丽的分割线--------------------------- 
1. NULL 
 
     只能作为指针变量的值. 如果1个指针变量的值是NULL值代表. 代表这个指针不指向内存中的任何1块空间
 
     NULL其实等价于0  NULL其实是1个宏. 就是0
 
 
  2. nil
 
     只能作为指针变量的值. 代表这个指针变量不指向内存中的任何空间. 
     nil其实也等价于0 也是1个宏. 就是0.
 
     所以, NULL和nil其实是一样的 。
 
 
  3. 使用建议.
    
     虽然使用NULL的地方可以是nil 使用 nil的地方可以使用NULL 但是不建议大家去随便使用.
 
     C指针用NULL
         int *p1 = NULL; p1指针不指向内存中的任何1块空间.
 
     OC的类指针用nil
         Person *p1 = nil; p1指针不指向任何对象.
 
 
  4. 如果1个类指针的值为nil 代表这个指针不指向任何对象.
     Person *p1 = nil;
 
     那么这个时候 如果通过p1指针去访问p1指针指向的对象的属性 这个时候会运行报错.
     那么这个时候,如果通过p1指针去调用对象的方法 运行不会报错 但是方法不会执行 没有任何反应



----------------------------------华丽的分割线--------------------------- 
1. 同类型的指针变量之间是可以相互赋值的.
 
     Person *p1 = [Person new];
     Person *p2 = p1; 这是完全没有问题的. p1和p2的类型都是Person指针类型的.
 
     代表将p1的值赋值给p2 而p1的值是对象的地址 所以就把对象的地址赋值给了p2
 
     所以p1和p2指向了同1个对象.
 
     无论通过p1还是p2去修改对象,修改的都是同1个对象.
 
 
  2. 目前为止,只要你看到new 就说明新创建了1个对象.



----------------------------------华丽的分割线--------------------------- 
分组导航标记:
 
 
   1). #pragma mark 分组名 
 
       就会在导航条对应的位置显示1个标题.
 
   2). #pragma mark -
 
       就会在导航条对应的位置显示1条水平分隔线.
 
   3). #pragma mark - 分组名
 
       就会在导航条对应的位置先产生1条水平分割线.再显示标题.



----------------------------------华丽的分割线--------------------------- 

1. 我们之前在C中学习的函数,就叫做函数.
 
      void test()
      {
 
      }
 
 
  2. 在OC类中写的方法.就叫做方法.
 
      - (void)sayHi;
 
 
 
  3. 相同点:
 
     都是用来封装1段代码的. 将1段代码封装在其中, 表示1个相对独立的功能
     函数或者方法只要被调用.那么封装在其中的代码就会被自动执行.
 
 
  4. 不同点:
     
     1). 语法不同.
     2). 定义的位置不一样.
         OC方法的声明只能写在@interface的大括弧的外面,实现只能写在@implementation之中.
         函数除了在函数的内部和@interface的大括弧之中 其他的地方都是可以写.
 
 
         就算把函数写在类中 这个函数仍然不属于类 所以创建的对象中也没有这个函数.
         注意; 函数不要写到类中.虽然这样是可以的 但是你千万不要这么做 因为这么做是极度的不规范的.
 
 
     3). 调用的方式也不一样.
 
         函数可以直接调用.
         但是 方法必须要先创建对象 通过对象来调用.
 
 
     4). 方法数是属于类的. 有1个伐木累. 有个归属感.
         而函数是1个孤魂野鬼, 就是1个独立的.


----------------------------------华丽的分割线--------------------------- 
1. 最容易犯错
 
     1).  @interface是类的声明. @implementation是类的实现 他们之间不能相互嵌套
 
     2).  类必须要先声明然后再实现
 
     3).  类的声明和实现必须都要有 就栓没有方法 类的实现也不必不可少的.
 
     4).  类的声明必须要放在使用类的前面.
          实现可以放在使用类的后面

 
     5).  声明类的时候 类的声明和实现必须要同时存在.
          特殊情况下可以只有实现 没有声明.
 
          虽然可以这样,但是我们平时在写类的时候千万不要这么写 因为这么写是极度不规范的 会被别人曹晓的.
 
 
     6)  属性名一定要以下划线开头 这是规范. 否则后面的知识点你就对不上号.
         类名 每1个单词的首字母大写.
 
 
     7). 属性不允许声明的时候初始化
 
         在为类写1个属性的时候 不允许在声明属性的时候为属性赋值.
 
 
     8).  OC方法必须要创建对象通过对象名来调用
 
 
 
     9).   方法只有声明 没有实现
 
 
          a. 如果方法只有声明 没有实现  编译器会给1个警告  不会报错.
 
          b. 如果指针指向的对象 有方法的声明 而没有方法的实现 那么这个时候通过指针来调用这个方法
 
              在运行的时候  就会报错.
 
        
            unrecognized selector sent to instance 0x100420510
 
            只要你看到了这个错误.说明要么对象中根本就没有这个方法. 要么只有方法的声明而没有方法的实现.



----------------------------------华丽的分割线--------------------------- 
1. 所有的类都写在main.m这个源文件之中的.
    
     后果: 后期的维护就非常的不方便.也不利于团队开发
 
 
 
  2. 推荐的方式
 
     把1个类写在1个模块之中. 而1个模块至少包含两个文件.
 
     .h 头文件
 
         写的类声明 因为要用到Foundation框架中的类 NSObject 所以在这个头文件中要引入Foundation框架的头文件.
 
         然后将类的声明的部分写在.h文件中
 
     .m 实现文件
         
         先引入模块的头文件 这样才会有类的声明
         再写上类的实现.
 
 
 
     如果要用到类. 只需要引入这个了模块的头文件就可以直接使用了.
 
 
 
  3. 添加类模块的更简洁的方式
 
     NewFile  Cocoa Class 自动生成模块文件  .h  .m 
     自动的将类的声明和实现写好.
 
     填写的名称是决定模块文件的名称. 类名是可以自己再改的
     但是建议模块的文件名和模块中的类名保持一致.这样方便代码的管理.
 
 
 
  4. 当我们要使用这个类的时候,需要先将这个类的头文件先引进来.才可以使用.



----------------------------------华丽的分割线--------------------------- 
 1. 对象和方法.
 
     对象作为方法的参数,对象作为方法的返回值.
 
 
 
  2. 类的本质是我们自定义的1个数据类型. 因为对象在内存中的大小是由我们决定的.
     多写几个属性 对象就大一些 少写几个属性 对象占用的空间就小一些.
 
     什么是数据类型: 是在内存中开辟空间的1个模板.
 
 
  3. 既然类是1个数据类型,那么类就可以作为方法的参数.
 
     - (void)test:(Dog *)dog;
 
     这个是完全没有问题的.
 
 
 
  -------语法注意-------------
  1. 当对象作为方法的参数的时候. 参数应该怎么写 参数类型是类指针,
 
     - (void)test:(Dog *)dog;
 
 
  2. 调用方法的时候 如果方法的参数是1个对象.
 
     那么给实参的时候,实参要求也必须是1个符合要求的对象. 否则就会出问题.
 
 
  3. 当对象作为方法的参数传递的时候,是地址传递.
     所以 在方法内部通过形参去修改形参指向的对象的时候 会影响实参变量指向的对象的值.
 
 
 
 
  --------------
 
  对象也可以作为方法的返回值.
 
  1.什么时候方法的返回值是1个对象呢?
 
    当方法执行完毕之后,如果有1个对象方法的内部不知道如何处理.并且这个对象是调用者翘首以盼的.
    那么这个时候我们就应该将这个对象返回.
 
 
  2.如果方法的返回值是1个对象,那么返回值类型应该写 类指针.



----------------------------------华丽的分割线--------------------------- 
1. 对象作为类的属性.
     
     1). 类的属性代表什么?
         代表类所拥有的东西. 设计类的时候.我们怎么知道这个类有哪些属性呢?分析这类事物拥有什么东西.
         拥有的东西就可以作为这个类的属性.
 
         人有姓名、年龄、性别、身高、钱.
 
         空调类:品牌、颜色、大小、匹数.
 
 
     2). 类的方法代表什么?
         代表这类事物具有的行为.具有的功能.
         设计类的时候.我们如何知道这个类有哪些方法呢?
         那么就分析这类事物具有哪些行为，这个类事物具有哪些功能,会做什么?
 
         人: 走路 吃饭 睡觉 唱歌..
         空调: 制冷.制热.

  2. 有1个人类,还有1个狗类.
     人养了一条狗，人拥有1条狗.
     如何描述这个关系:人拥有1条狗.
 
     人拥有1条狗,那么就把狗作为人的1个属性.
 
 
  3. 对象完全可以作为另外1个类的属性.代表这个类拥有这个对象.
 
     A类拥有1个B对象,那么就将B对象作为A类的属性.
 
 
  4. 当A类作为B类的属性的时候. 在创建B类对象的时候, B类对象中的属性仅仅只是1个指针变量. 
     默认情况下并没有创建A对象.
 
 
  5. 重点:
     1). 什么时候1个类可以作为另外1个类的属性.
 
         吊扇:
         扇叶:
 
     2). 属性的本质其实是1个变量.
 
 
     3). 如何访问对象的属性对象的成员.



----------------------------------华丽的分割线--------------------------- 
 1. 对象在内存中的存储.
     Person *p1 = [Person new];

  2. nil与NULL
     a. 只能作为指针变量的值 代表不执行任何空间.
 
  3. 多个指针指向同1个对象.
 
 
  4. 分组导航标记.
 
  5. 方法与函数.
 
  6. 犯错列表.
 
  7. 对象与方法.
     1). 类的本质是我们自定义的1个数据类型.
         Person *p1;
 
     2). 类既然是1个数据类型.那么类 类型的 指针变量完全可以当做方法的参数或者返回值
 
     3). 当类作为方法的参数的时候. 在方法执行的时候 参数只是1个指针而已 没有创建对象.
         为参数传值以后. 形参指针和实参指针指向了同1个对象.
 
         在方法的内部通过实参指针去访问对象 访问的就是实参指针指向的对象2.
 
     4). 对象作为方法的返回值.
 
         方法的作用就是创建1个对象 把这个对象的地址返回给调用者.
 
 
     5). 
 
 
 
   8. 表示平面上的1点:
       
 
      x左边 和y坐标.



----------------------------------华丽的分割线--------------------------- 
1. 什么是错误?
 
     一般情况下,错误指的是我们写的源代码不符合语法规范. 然后编译报错.
 
     后果: 程序无法编译. 
 
     解决: 将不符合语法规范的代码改为符合语法规范的代码不就可以了吗.
 
 
  2.什么是Bug?
     
     程序可以编译 链接  执行.程序执行的结果并不是我们所预想的那样.
 
     解决: 通过调试寻找发生Bug的原因.
 
 
  3.什么是异常?
 
     程序可以编译 链接 执行.
     当程序在执行的时候 处于某种特定条件下 程序的执行就会终止.
 
 
     异常的后果: 程序会立即崩溃.程序立即终止运行.并且后面的代码不会执行了
 
 
  4. 如何处理异常.
    
 
     1). 目的: 为了让程序在执行的时候如果发生了异常而不崩溃 而是继续往下执行.
 
     2). 语法:
 
         @try
         {
 
         }
         @catch(NSException *ex)
         {
 
         }
 
        将有可能发生异常的代码放在@try中.
        当@try中的代码在执行的时候.如果发生了异常.不会崩溃,而是会立即跳转到@catch中去执行里面的代码.
        当@catch的代码执行完毕之后 结束@try...@catch往下执行.
        如果@try中的代码在执行的时候 没有发生异常. 就会略过@catch往下执行.
 
    3). 当@try中的代码在执行的时候发生了异常.@try块发生异常的后面的代码不会执行.而是立即转到@catch
 
 
 
 5. @catch中的代码只有在@try的代码发生异常的时候才会执行.
    所以,@catch中我们一般情况下写处理异常的代码.
    发生这个异常以后 要做神马事情.
 
 
 6. @catch的参数NSException *ex 通过%@打印出ex指向的对象的值.
     可以拿到发生异常的原因
 
 
 7. @try...@catch后面还可以跟1个@finally
    @finally中的代码.无论@try中是否发生了异常都会被执行.
 
 
 8. @try..@catch并不是万能的.不是所有的运行时错误都可以处理的.
 
    C语言的异常是无法处理的。
 
    在实际的开发过程中 使用@try用的相对比较少的.
 
 
    避免异常我们最常用的方式还是逻辑判断.



----------------------------------华丽的分割线--------------------------- 
0. 在1个Target中无法访问另外1个Target中的类.
 
 
 
  1. OC中的方法分为两种.
 
     1).对象方法/实例方法:
 
        我们之前学习的方法 就叫做对象方法. 如果想要调用对象方法就必须要先创建对象 通过对象名来调用.
 
     2).类方法.
 
        类方法的调用不依赖于对象.如果要调用类方法 不需要去创建对象.而是直接通过类名来调用.
 
 
  2. 声明.
 
     1).对象方法的声明:
    
        对象方法声明使用 - 号
        - (返回值类型)方法名;
        - (void)sayHi;
 
 
     2).类方法的声明:
        类方法声明使用 + 号.
        + (返回值类型)方法名;
 
        和对象方法的声明实现除了+和- 其他的都是一样的 
 
       
 3.调用.
 
   1). 对象方法: 先创建对象 再通过对象名来调用.
 
   2). 类方法: 不需要通过对象名来调用 所以如果要调用类方法不需要创建对象.
       而是直接使用类名来调用
 
       [类名 类方法名];
 
 
 
 4.分析一下 类方法和对象方法的调用过程.
 
 
   类方法的特点
   1). 节约空间: 因为调用类方法不需要创建对象. 这样就节约了空间.
 
   2). 提高效率: 因为调用类方法不需要拐弯 直接找到类 直接执行类中的类方法.
 
 
 5. 在类方法中不能直接访问属性.
 
    1). 属性是在对象创建的时候.跟随着对象一起创建在对象之中.
 
    2). 类第1次被访问的时候,会做类加载. 是把类的代码存储在代码段
 
    因为属性只有在对象创建的时候才会创建在对象之中.
    而类方法在执行的时候.有可能还没有对象. 对象都没有 你访问个毛的属性.
 
    虽然不能直接访问属性. 但是我们可以在类方法中创建1个对象 访问这个对象的属性.
 
 
 
 6. 在类方法中也不能通过self直接调用当前类的其他的对象f方法
    因为对象方法只能通过对象来调用 而这个时候没有对象.
 
     
 
 7. 在对象方法中可以直接调用类方法.
 
 
 8. 什么时候我们可以将方法定义为类方法呢?
 
    如果方法不需要直接访问属性 也不需要直接调用其他的对象方法.
    那么我们就可以将这个方法定义为类方法
 
    这样就 节约空间 提高效率.
 
 
 9. 关于类方法的规范.
 
    1). 如果我们写1个类,那么就要求为这个类提供1个和类名同名的类方法.
        这个方法创建1个最纯洁的对象返回.
 
        因为苹果和高手写的类都遵守这个规范.
 
 
    2). 如果你希望创建爱的对象的属性的值由调用者指定 那么就为这个类方法带参数.
        
        类名WithXXX: ......



----------------------------------华丽的分割线--------------------------- 
1. NSString是1个数据类型.用来保存OC字符串的.
 
 2. 其实NSString是Foundation框架中的1个类.
    作用: 存储OC字符串的
    所以.OC中的字符串本质上是用NSString对象来存储的.
 
 
 3. 其实完整的标准的创建NSString对象的方式
 
    NSString *str0 = [NSString new];
    NSString *str1 = [NSString string];
 
    这种方式创建的字符串是空字符串 @""
 
    但是.NSString是我们最常用的1个对象 所以OC使用了1种更为简单的方式来创建字符串对象.
 
    直接使用@来表示1个OC字符串.
 
    @"jack" 这个其实本质上是1个NSString对象.
 
    NSString *str = @"jack";
 
    @"jack" 是1个NSString对象  str的值是这个对象的地址.
 
    %p 打印的是指针变量的值
    %@ 打印的是指针变量指向的对象.
 
 
 4. NSString最常用的类方法.
 
    1). + (instancetype)stringWithUTF8String:(const char *)nullTerminatedCString;
        instanceType 作为返回值 代表返回的是当前这个类的对象.
 
        作用:将C语言的字符串转换为OC字符串对象.
 
 
    2). + (instancetype)stringWithFormat:(NSString *)format, ...  使用频率100分.
 
        作用: 拼接1个字符串对象.使用变量或者其他数据拼接成OC字符串.
 
         int age = 19;
         NSString *name = @"小明";
         
         
         //@"大家好我叫xx 我的年龄是xx"
         NSString *str =  [NSString stringWithFormat:@"大家好,我叫%@,我今年%d岁",name,age];
         NSLog(@"str = %@",str);
 
 
 5. 最常用的对象方法
    1). length方法 返回值为NSUInteger 其实就是unsigned long
        得到字符串的字符的个数 可以处理中文.

 
    2). 得到字符串中指定下标的字符.
        - (unichar)characterAtIndex:(NSUInteger)index;
        返回值是unichar 其实就是unsinged short 占据2个字节.
 
 
        如果要输出unichar变量的值使用%C 钛金眼睁大 这是大写的C 
        %c
 
 
    3). 判断两个字符串的内容是否相同.
 
        a. 判断两个字符串的内容是否相同 不要用==去判断  因为这样有可能会出问题.
 
        b. 判断相等的方式.
 
           - (BOOL)isEqualToString:(NSString *)aString;
            
           所以,判断两个字符串是否相等 应该使用这个方法区判断 才会得到正确的结果.
 
 
     4).比较字符串的大小.
 
        - (NSComparisonResult)compare:(NSString *)string;
 
        完全可以使用int类接收结果. 因为返回值是1个枚举.
        返回值如果是 -1 说明小于
                   0  等于
                  1   大于.



----------------------------------华丽的分割线--------------------------- 
1. 我们之前创建对象的做法.
     Person *p1 = [Person new];
     让1个指针指向1个对象 这个指针就叫做这个对象的名字.
 
 
  2. 匿名对象.
     没有名字的对象,如果我们创建1个对象,没有用1个指针存储这个对象的地址.
     也就是没有任何指针指向这个对象 那么这个对象就叫做匿名对象。
 
 
  3. 如何去使用1个匿名对象呢?
 
     因为new实际上1个类方法. 这个方法做的事情创建对象(4个步骤). 返回值是创建的对象的地址.
     [Person new] 这句代码的结果实际上就是创建的那个对象的指针. 那我们可以直接使用.
 
     [Person new]->_name = @"jack";
     [[Person new] sayHi];
 
 
  4. 注意点.
 
     1). 匿名对象只能使用1次. 
 
     2). 每次创建匿名对象都是不同的对象 。
         [Person new]->_name = @"jack"；
         创建了1个对象
         
         [Person new]->_age = 18;
         又创建了1个对象
         [[Person new] sayHi];
         第3个对象.
 
  5.有神马用?
 
    1). 如果某个对象的成员只会被我们使用1次.用完之后这个对象再也不需要了 那么就可以使用匿名对象.
 
    2). 如果方法的参数是1个对象,而调用者为这个参数赋值的对象 就是专门来给这个方法传递的
        并且这个对象调用者不会使用 那么这个时候就可以直接为方法传递1个匿名对象 。



----------------------------------华丽的分割线--------------------------- 
1. 面向对象的三大特征是什么?
 
     封装
       类就是更高级别的封装.类将数据和行为封装为了1个整体.
       好处:
       -> 屏蔽内部的实现.外界不需要知道内部是如何实现的 只需要知道这个对象有什么用.
       -> 方便操作.
       -> 后期的维护十分的便利.
 
 
     继承
 
     多态
 
 
  2. 存在的问题.
 
     就是为对象的属性赋值的时候 语法上其实只要数据的类型是属性的类型就是可以的.
     但是,情理上这么做是不合的.
     
     就像Person对象有1个int类型的属性_age 表示1个人的年龄.
     为这个对象的_age属性赋值的时候 其实只要是int类型的数据 语法上都是完全可以的.
     但是1个人的年龄 正常情况下是在 0-200之间的.
 
     解决的问题:
     在为对象的属性赋值的时候,我希望将这个数据做1个逻辑验证.
     如果为属性赋的值在这个逻辑范围之内 那么我们就把这个值赋值给属性.否则我们就做默认处理.
 
     就像我们希望为Person对象的_age属性赋值的时候,要判断1下为_age属性赋的值是不是在0-200之内.
     否则我们就做默认处理.
 
 
  3.如何实现这个需求
 
     1). 将属性的@public去掉.因为一旦写上@public就意味着外界可以直接访问对象的这个属性.
         外界一旦可以直接访问这个属性 那么外界就可以任意的为这个属性赋值 这个时候你拦都拦不住.
 
         去掉@public 外界就无法直接访问这个属性 也就无法赋值了.
 
 
     2). 为类提供1个方法,这个方法专门为这个属性赋值.这个方法我们叫做setter
 
         a. 这个方法一定是1个对象方法 因为这个要为属性赋值.
         b. 这个方法没有返回值. 因为这个方法做的事情 仅仅是为属性赋值就可以了.
         c. 这个方法的名称必须以set开头. 跟上去掉下划线首字母大写的属性名.
         d. 这个方法一定是有参数的. 参数的类型和属性的类型一致.参数的名称和属性的名称一致(去掉下划线)
         e. 在方法的实现中,判断传入的数据是否符合逻辑.如果符合逻辑则赋值 否则做默认处理.
         f. 外界想要为对象的属性赋值 那么就调用这个对象的setter方法 将要赋值的数据传入给这个方法.
            方法会对这个数据进行验证 如果符合验证 就会吧数据赋值给属性 否则就会做默认处理.
 
 
         练习:
 
     3). 这么一写,我们确实可以在为对象的属性赋值的时候做1个逻辑验证了.
         但是问题就是 在外界无法取出属性的值了.
         那就再写1个方法,专门用来返回属性的值.这个方法我们叫做getter方法.
 
         a. 这个方法一定是1个对象方法 因为这个方法做的事情是拿到属性的值返回.
         b. 这个方法肯定有返回值 返回值的类型和属性的类型一致.
         c. 这个方法的名称直接就是属性的名称(去掉下划线的)
         d. 这个方法没有参数
         e. 这个方法的实现是直接将属性的值返回.
         f. 这个时候,如果外界希望得到属性的值.那么就只需要调用这个getter方法就可以了.
 
 
         课堂练习;
         写1个Student类
 
         属性: 姓名 长度不能小于2 并且不能是@"毛泽东" @“胡锦涛” @"习近平"  @"无名"
              年龄  0-120  18
              语文  0-150  0
              数学
              英语
 
         方法: 介绍自己的名字和年龄显示自己的总分数和平均分.
 
         
 
 4. 都是你的错
 
    1). 属性的@public修饰符没有去掉.如果没有去掉 就算你的getter setter封装的再牛X 也没有N用.
 
    2). 搞不清楚对象. 判断参数的值富是否符合逻辑 将参数赋值给属性.
 
 
    3). getter setter 方法名极度不规范.
 
 
 
 5. 什么时候需要为属性封装setter和getter？
 
 
    1). 只要属性需要被外界访问.就要为这个属性封装setter和getter。
        哪怕在赋值或者取值的时候没有任何逻辑验证.
 
    2). 如果属性只在类的内部访问.那么就不需要为其封装getter setter
 
    
 6. 只读封装与只写封装.
 
    只读封装: 为属性封装的时候 只提供getter 不提供setter
    只写封装: 为属性封装的时候.只提供setter 不提供getter



----------------------------------华丽的分割线--------------------------- 
对象与对象之间的关系.
 组合关系
 依赖关系
 关联关系
 继承关系
 
 
 
 
 
 
 
 1. 组合关系.
    1个对象是由多个对象组合起来的.
    比如.计算机对象. 是由主板对象、CPU对象、内存对象、硬盘对象...组合起来的.
 
    主板、内存、硬盘作为计算机对象的属性.
 
 
    那么这个时候,计算机对象和主板、内存、硬盘的关系为 组合关系.
 
 
 
 2. 依赖关系
    1个对象的方法的参数是另外1个对象.那么我们就说他们的关系是依赖关系.
 
    比如,B类是A类方法的参数,我们就说A类依赖于B类.
 
    美女打电话的例子.
 
    人类:
    callWithPhone:(Phone *)phone;
    我们就说人类依赖于电话类. 人要打电话 就必须要有电话对象.
 
    电话类:
 
 
    耦合度:  当修改1个对象的时候 对另外1个对象的影响程度.
    1个类修改了 另外1个类就玩完.
    低耦合: 当修改1个对象的时候 对另外1个对象的影响较小甚至没有影响.
    高内聚: 1个对象仅仅做自己相关的事情.
    单一职责原则. 1个类只做自己的事情.别人的事情给别人做.
    
    eatShit;
 
 
 3. 关联关系
    关联体现的是两个类之间语义级别的一种强依赖关系，
    比如我和我的朋友，这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性 的，
    而且双方的关系一般是平等的。关联可以是单向、双向的。
    表现在代码层面，
    为被关联类B以类的属性形式出现在关联类A中，也可能是关联类A引用了一个类 型为被关联类B的全局变量。
 
    案例:人使用iPad听歌.



----------------------------------华丽的分割线--------------------------- 
计算机类的属性:
    CPU 内存 主板 显卡 声卡 网卡。。。
    开机 关机 放片.
 
 
 
 1个类是由其他的几个类联合起来组合而成.那么他们之间的关系就叫做组合关系.
 
 
 Person类
   属性: 头 身体 脚



----------------------------------华丽的分割线--------------------------- 
关联关系: 1个类作为另外1个类的属性.但是他们不是组合关系 而是1个拥有的关系.
 
          拥有关系. 关联关系.



----------------------------------华丽的分割线--------------------------- 
利用面向对象,模拟如下流程.
 
  士兵 开枪 射出子弹.
 
 
  士兵类:
     属性: 姓名 兵种.
     行为: 开火的方法.
 
  枪类:
     属性: 型号.射程.子弹数量.
     行为: 射击.
 
    
  //子弹类:
 
 
  枪有1个弹夹 弹夹中再有子弹.



----------------------------------华丽的分割线--------------------------- 
1. @try...@catch异常处理.
 
  2. 类方法.
     a. 声明.
     b. 调用.
     c. 特点.
     d. 注意. 在类方法中不能直接访问属性.也不能使用self直接调用其他的对象方法.
             在类方法的内部创建1个对象 访问这个对象的成员.
             在对象方法中可以直接使用类名来调用类方法.
 
     e. 什么时候
     f. 规范.
 
 
   3. NSString
 
      a. NSString是1个类.
         NSStrng *str = @"jack";
 
      b. 常用的方法.
 
         把C字符串转换为OC字符串.
         拼接的方式拼接字符串.
         长度
         得到指定下标的字符
         相等
         比较.
 
 
    4. 匿名对象.
      a. 匿名对象.
      b. 如何使用匿名对象.
      c. 匿名对象只能使用1次.
      d. 使用场景
 
 
    5.属性的封装.
      a. setter 和 getter 的规范
      b. 封装规范.
      c. 只读 只写.
 
 
    6.类与类之间的关系.
      组合
         1个类是由其他的多个类组合而成的. 电脑 CPU 主板 显卡.....
      依赖
      关联
         1个类拥有另外1个对象.
         Person iPad
      继承
 
 
 
   7. 突击



----------------------------------华丽的分割线--------------------------- 
1. 苹果提供了很多很多的框架.框架中有很多类 很多的函数 提供了一些数据类型.
 
     遇到的问题:
     a. 你如何知道到底有哪些框架
     b. 框架中有哪些类.
     c. 类只又有哪些牛X的方法.    
     d. 如何调用这些类.
 
     所有的这一切.Xode文档.详细的描述了这些信息.
 
 
  2. Xcode文档需要单独的安装.
 
 
     1). 在线安装.
 
 
     2). 离线安装.
        /Applications/Xcode.app/Contents/Developer/Documentation/DocSets



----------------------------------华丽的分割线--------------------------- 
 1. C语言中的static
 
     a. 修饰局部变量.
     b. 修饰全局变量.
     c. 修饰函数.
 
 
  2. OC中的static关键字.
 
     a. static不能修饰属性 也不能修饰方法.
     b. static可以修饰方法中的局部变量.
 
         如果方法中的局部变量被static修饰,那么这个变量就会被变成静态变量.
         存储在常量区 当方法执行完毕之后 不会回收 下次再执行这个方法的时候 直接使用 而不会再声明了.
 
 
 
  3. 如果方法的返回值是当前类的对象,那么方法的返回值就写instancetype



----------------------------------华丽的分割线--------------------------- 
 1. 在方法的内部可以定义1个和属性名相同的局部变量.
     这个时候 如果在方法中访问这个同名的变量,访问的是局部变量.
     问题1: 如果这个时候我就是要访问那个同名的属性,怎么办?
 
     问题2: 在1个对象方法中要调用当前对象的另外1个对象方法怎么办?
 
 
 
  2. self:自己的.
     和Java、C#中的this关键字有1点点像.
 
     可以在对象方法和类方法中使用.
     self是1个指针. 在对象方法中self指向当前对象. 在类方法中self指向当前类.
 
 
  3. self用在对象方法中.
 
     1). self在对象方法中,指向当前对象.
 
         当前对象: 谁调用方法谁就是当前对象.
 
 
     2). 在对象方法中,self指向当前对象,然后这又有神马用?
 
         a. 可以使用self显示的访问当前对象的属性.
            self->属性.  代表访问的是当前对象的这个属性.
 
         b. 可以使用self来调用当前对象的其他的对象方法.
 
     3). 对象方法中使用self的场景.
 
         a. 必须使用self的场景.
            -> 如果在方法中存在和属性同名的局部变量,
               你如果想要访问同名的局部变量,直接写就可以了.
               你如果想要访问当前对象的同名属性 必须使用self
 
            -> 在对象方法中,如果要调用当前对象的其他的对象方法 必须使用self.
 
         b.选用self的场景.
          
            在方法中不存在和属性同名的局部变量 如果这个时候想要访问当前对象的属性
            用布用self效果都是一样的.都是访问的当前对象的属性.
 
 
         属性要求以下划线开头 局部变量不要求以下划线开头 按照这个规范来 实际上是不会重名的.
         
 
     
 4. 把slef用在类方法中.
 
    1). 类加载. 当类第1次被访问的时候 会将类的代码存储在代码区.
               代码区中用来存储类的空间也有1个地址.
 
 
    2). 在类方法中 self也是1个指针.执行当前这个类在代码段中的地址.
        self 在类方法中 就相当于是当前这个类.\
 
    3). 总结1下取到类在代码段中的地址的方式.
        a. 调试查看对象的isa指针的值.
        b. 在类方法中查看self的值.
        c. 调用对象的对象方法class 就会返回这个对象所属的类在代码段中的地址.
        d. 调用类的类方法class 就会返回这个类在代码段中的地址.
 
 
    4). 有神马用?
        可以在类方法中使用self来显示的调用本类的其他的类方法.
        使用建议,如果要在当前类方法中调用本类的其他的类方法 虽然可以直接使用类名 但是建议使用self
 
 
 
 
 5.  对象方法可以声明多次.但是只会认为有1次.
     对象方法如果有多次声明只能实现1次 否则就会报错.
 
     对象方法之间是不能重名的.
     类方法之间也是不可以重名的.
 
 
     但是,对象方法和类方法是可以重名的.
     通过类名来调用 调用的就是类方法
     通过对象名来调 调用的就是对象方法.

 
 6. 注意
 
    1). 在对象方法中, self代表当前对象.
        所以可以通过self访问当前对象的成员.
        
        在对象方法中 不能使用self调用本类的类方法.
 
 
    2). 在类方法中,self代表当前这个类.
 
        所以,可以通过self调用当前类的其他的类方法.
 
        在类方法中  不能使用self访问对象的成员. 不能去直接访问属性和调用对象方法.



----------------------------------华丽的分割线--------------------------- 
1. 遇到的问题.
     多个类具有相同的成员.
     a. 复制 粘贴.
        -> 代码冗余.
        -> 后期的维护不方便.
    
     b.使用继承.
 
 
  2. 继承的目的: 儿子类想拥有父亲类中的所有的成员.但是不想自己去定义,而是想凭空拥有.
 
 
  3. 继承的语法: 如何让1个类认另外1个类为爹 因为想拥有爹类中的所有的成员
 
     语法:
     @interface 类名 : 父亲类的名称
 
     @end
 
    
  4. 继承的效果:
 
     儿子类一旦从父亲类去继承.那么儿子类中拥有了父亲类中的所有的成员. 不用自己定义.
 
 
  5. 几个术语:
     
     @interface Student : Person
 
     1). Student类从Person类继承. Studdent类是Person类的子类 Person类是Student的父类.
     2). Student类从Person类派生. Student类是Person类的派生类.Person类是Student类的基类.
 
     子类一旦从父类继承 就意味着子类拥有了父类的所有的成员 而不用自己去定义.



----------------------------------华丽的分割线--------------------------- 
1. 在新创建类模块的时候 指定父类.
     Xcode就会自动的帮助你完成一系列的事情.
 
 
  2. 继承是类在继承.而不是对象在继承.
 
     子类从父类继承.子类中就拥有了父类中定义的所有的成员. 只是类继承.
 
     我们创建对象. 对象与对象之间是毫无关系的.
 
 
  3. 什么时候应该使用继承?
 
     如果发现另外1个类中的成员我也想有 那么这个时候就可以使用继承.
 
     千万不要为了继承而去继承. 不要为了仅仅是得到某个类的成员你就不顾伦理去乱继承.
 
 
     满足继承的关系 is a
     凡是满足is a关系的类 就可以拥有继承的关系.
     当A类是1个B类的时候 那么A类就可以从B类继承
 
     学生  人
     学生  狗 X 
     电风扇  电器
     汽车  交通工具.
    
     汽车  蛇.
 
 
  4. 再次的总结:
 
     1). 子类从父类继承,就意味着子类拥有了父类的所有的成员 包括属性 方法.
 
     2). 继承是类在继承.而不是对象在继承.
 
         子类对象中拥有父类对象中的同样的成员.
 
     3). 满足继承的关系. is a 只有满足is a关系的类才可以拥有继承关系.
 
 
 
  5. 如果有1个成员不是所有的子类都拥有的.那么这个成员就不应该定义在父类之中.
     因为一旦定义在父类之中.那么所有的子类全都有了.
 
     父类中只定义所有的子类都拥有的.只要不是所有的子类都拥有的 那么就不应该定义在父类之中.



----------------------------------华丽的分割线--------------------------- 
 1. 单根性
 
     1个类只能有1个父类 不能有多个父类.
 
 
  2. 传递性.
 
     A类从B类继承,B类从C类继承. 那么A类就同时拥有B、C类的成员.
 
  3. NSObject类.
    
     是Foundation框架中的类.在这个类中有1个类方法new
     这个方法是用来创建对象的.方法的返回值是创建的这个对象的指针.
 
     也就是说,如果要创建类的对象,就必须要调用这个new方法.
 
     如果我们想要让我们的类具备创建对象的能力,就必须要让我们的类直接的或者间接的从NSObject类继承.
 
     所以.要求: 我们写的类必须直接的或者间接的要NSObject类继承.
     如果你不继承,我们的类就无法创建对象. 那么我们的类就毫无意义.
 
 
     在NSObject类之中 还定义了1个属性. 这个属性叫做isa指针.
     所以,每1个子类对象中都有1个叫做isa的指针.
 
 
     NSObject类是OC中所有类的祖宗类. 因为OC中的类全部都是直接的或者间接的从它继承,



----------------------------------华丽的分割线--------------------------- 

 1. 子类中不能存在和父类同名的属性.
 
     因为子类从父类继承,就意味着子类拥有了父类的所有的成员 包括属性和方法.
     也就相当于子类中其实已经定义了.
     如果子类再定义1个同名的属性 很明显就冲突了.
 
 
  2. super关键字.
 
     1). 可以用在类方法和对象方法之中.
 
     2). 在对象方法中可以使用super关键字调用当前对象从父类继承过来的对象方法.
 
     3). 在类方法中 super关键字可以调用当前类从父类继承过来的类方法.
 
         a. 类方法也能被子类继承. 父类中的类方法可以使用父类名来调用 也可以使用子类名调用.
 
         b. 在子类的类方法中 可以使用super关键字调用父类的类方法.
 
     4). super只能用来调用父类的对象方法或者类方法  不能用来访问属性.
 
 
  3. 子类从父类继承.
 
     1). 相当于子类模板中拥有了父类模板中的所有的成员.
 
     2). 创建1个子类对象,仍然是根据子类模板来创建对象.
         只不过子类模板中拥有父类模板中的成员.
 
         所以,子类对象中既有子类的成员也有父类的成员.
 
 
     3). super特指这个方法是从父类继承过来的.
 
         super是指当前类或者对象的这个方法是从父类继承过来的.


----------------------------------华丽的分割线--------------------------- 
 1. 访问修饰符: 用来修饰属性.可以限定对象的属性在那1段范围之中访问.
 
     @private: 私有 被@private修饰的属性只能在本类的内部访问.
               只能在本类的方法实现中访问.
 
     @protected: 受保护的. 被@protected修饰的属性只能在本类和本类的子类中访问.
                只能在本类和子类的方法实现中访问.
 
     @package: 被@package修饰的属性 可以在当前框架中访问.
 
 
     @public: 公共的.被@public修饰的属性 可以在任意的地方访问.
 
 
  2. 如果不为属性指定访问修饰符 那么默认的就是@protected
 
 
  3. 子类仍然可以继承父类的私有属性.
     只不过,在子类中无法去直接访问从父类继承过来的私有属性.
     但是如果父类中有1个方法再为属性赋值或者取值.
     那么子类可以调用这个方法间接的访问父类的私有属性.
 
  4. 访问修饰符的作用域.
 
     从写访问修饰符的地方开始往下.直到遇到另外1个访问修饰符或者结束大括弧为止。
     中间的所有的属性都应用这个访问修饰符.
 
 
  5. 使用建议.
     1). @public 无论什么情况下都不要使用. 属性不要直接暴露给外界.
 
     2). @private 如果属性只想在本类中使用 不想在子类中使用 那么就使用它.
 
     3). @protected: 如果你希望属性只在本类和本类的子类中使用.
 
     推荐使用默认的@protected
 
 
  6. 访问修饰符只能用来修饰属性 不能用来修饰方法.



----------------------------------华丽的分割线--------------------------- 
1. 我们刚才讲的@private修饰的属性就叫做私有属性.
      只能在类的内部访问.
 
      但是在外界的时候,Xcode仍然会提示这个对象中有这个属性 只不过没权访问.
 
      我们想要实现的效果:真私有. 让外界不知道对象里面有这么1个属性.
 
 
    
   2. 其实在@implementaion之中也可以写1个大括弧.
      把属性定义在@implementation的大括弧之中.
 
      这里面的属性. 是1个私有属性. 各种访问修饰符无效.
      外界根本就不会提示.
 
      将属性定义在@implementation之中 和 将属性定义在@interface之中并标记为@private
      唯一的区别: 提示和不提示. 都不能在外界访问.
 
    
   3. 私有方法.
      
      方法不写声明,只写实现. 那么这个方法就是1个私有方法.
      只能在本类的其他方法中调用 不能再外界调用.



----------------------------------华丽的分割线--------------------------- 
 1. 里氏替换原则 --- LSP
 
     子类可以替换父类的位置.并且程序的功能不受影响.
 
     为什么?
     1). 父类指针迫切的需求要1个父类对象,而我们给了1个子类对象,
         这是完全没有问题的. 因为子类就是1个父类嘛.
 
     2). 因为父类中拥有的成员 子类都有. 所以不会影响程序的功能.
 
 
  2. 里氏替换原则的表现形式.
 
     当1个父类指针指向1个子类对象的时候,这里就有里氏替换原则.
 
 
  3. LSP的作用。
 
     1). 1个指针中不仅可以存储本类对象的地址还可以存储子类对象的地址.
 
     2). 如果1个指针的类型是NSObject类型的,那么这个指针中可以存储任意的OC对象的地址.
 
     3). 如果1个数组的元素的类型是1个OC指针类型的 那么这个数组中不仅可以存储本类对象还可以存储子类对象.
 
     4). 如果1个数组的元素是NSObject指针类型 那么意味着任意的OC对象都可以存储到这个数组之中.
 
     5). 如果1个方法的参数是1个对象,那么我们在为这个参数传值的时候.
         可以传递1个本类对象 也可以传递1个子类对象.
         对方法中的代码不会有丝毫的影响.
 
 
  4. 当1个父类指针指向1个子类对象的时候.
     这个时候,通过这个父类指针就只能去调用子类对象中的父类成员.
     子类独有的成员无法访问.
 
     只需要记住,不要问为什么 时机一到我自然会告诉你!



----------------------------------华丽的分割线--------------------------- 
1. 子类从父类继承,子类就继承了父类的方法.
     
     子类继承了父类的方法,就意味着子类拥有了这个功能.
 
     有的时候: 虽然子类也拥有父类的这个行为. 但是这个行为的具体的实现和父类不同.
 
 
  2. 这个时候怎么办?
     拥有父类的行为,但是行为的具体的实现和父类的实现不一样.

     那么子类就自己按照自己的方式重写这个方法就可以了.
 
     如何重写: 直接在类的实现中将这个方法重新实现一遍就可以了.
 
 
  3. 什么时候子类需要重写父类的方法.
 
     子类拥有父类的行为,但是子类这个行为的实现和父类不一样.那么就按照自己的方式重写这个方法就可以了.
 
 
 
  4. 当1个父类指针指向1个子类对象的时候.
     通过这个父类指针调用的方法 如果在子类中重写了.
     调用的就是子类重写的方法.
 
 
 
  5. 多态.
 
     指的是同1个行为,对于不同的事物具有完全不同的表现形式.
 
     找三个人过来.
 
     医生
     演员
     理发师
 
     cut 指令.
 
     同1个行为 具备多种形态.



----------------------------------华丽的分割线--------------------------- 
1. 杀手
        方法: 可以杀各种各样的人.
 
  2. 每1个人被杀的时候,都要叫. 但是每1个人叫的形式是不一样的.
 
     每1个人都有1个叫的方法.
 
     Person：
 
     男人 超级赛亚人 火星人.



----------------------------------华丽的分割线--------------------------- 
1. %p 打印的是指针变量的值.
     %@ 打印的是指针指向的对象.
 

  2. 如果我们使用%@打印1个对象
 
     输出的格式:  <对象所属的类名:对象的地址>
 
 
  3. 原理:
 
     当我们使用%@打印1个对象的时候, NSLog函数的底层实现.
 
     1). 调用传入的对象的 description方法.
 
     2). 拿到这个方法的返回值 这个返回值是1个字符串.
 
     3). 将这个字符串输出.
 
 
 
  4. description方法是定义在NSObject类之中的.
     所以每1个OC对象都有这个方法.
 
     这个方法在NSObject类中的实现是这样的:
 
     返回的字符串格式 @"<对象所属的类名:对象的地址>"
 
 
 
  5. 什么时候需要重写description方法呢?
 
     如果你希望使用%@打印1个对象的时候 你希望这个对象打印的个数是我们自定义的.
     那么就可以重写这个方法.



----------------------------------华丽的分割线--------------------------- 
1. Xcode文档的安装与使用.
 
 
  2. static关键字修饰方法中的局部变量.
 
 
  3. self关键字.
 
     1). 在对象方法中.
        
         父类的成员对于子类来讲,也是属于子类的.所以父类的成员在子类的方法中也可以使用self
 
     2). 在类方法中.
 
 
  4. 继承.
 
     1). 继承的目的:
 
     2). 继承的语法:
 
     3). 继承的效果:
 
     4). 继承是类在继承而不是对象在继承.
 
     5). 满足继承的关系.
         is a
     6). 继承的特点.

     7). NSObject类.
 
     8). 访问修饰符.
 
  5. 私有属性和私有方法.
 
 
  6. 里氏替换原则.
 
     1).什么是LSP
        Person *p1 = [Student new];
     2).为什么LSP是可以的.
 
     3).LSP的表现形式.  父类指针指向子类对象.
    
     4).LSP的好处.
 
     5).当1个父类指针指向1个子类对象的时候.只能通过这个父类指针访问这个对象中的父类成员.
 
 7. 方法重写
 
    1). 什么时候需要方法重写?
 
    2). 如何重写
 
    3). LSP的时候 通过指针调用的方法被子类重写了 那么调用的是子类重写的.
 
 
 8. 多态.



----------------------------------华丽的分割线--------------------------- 
 1. 创建1个对象,这个对象在内存中是如何分配的.
 
 
     1). 子类对象中有自己的属性和所有父类的属性.
 
 
     2). 代码段中的每1个类都有1个叫做isa的指针,这个指针指向它的父类.
         一直指到NSObject
 
         [p1 sayHi];  //假设p1是Person对象.
         先根据p1指针找到p1指向的对象,然后根据对象的isa指针找到Person类.
         搜索Person类中是否有这个sayHi方法 如果有执行
         如果没有 就根据类的isa指针找父类 。。。。。
         NSObject 中如果没有就报错.



----------------------------------华丽的分割线--------------------------- 
 1. 人类
     姓名 性别 年龄.
     
 
  2. 书类
     书名 作者 出版社 出版日期.
 
    
  3  学生类
     姓名 性别 年龄 学号 书.
 
     读书
 
 
 
  日期: 年 月 日.
 
 
----------------------------------华丽的分割线--------------------------- 
 1. 人类
 
 1. 结构体与类的相同点
 
    都可以将多个数据封装为1个整体.
 
 
    struct Date
    {
        int year;
        int month;
        int day;
    };
 
    @interface Date : NSObject
    {
        int year;
        int month;
        int day;
    }
    @end
 
 
 2. 结构体与类的不同点
 
    1). 结构体只能封装数据,而类不仅可以封装数据还可以封装行为.
 
    2). 结构体变量分配在栈空间 (如果是1个局部变量的情况下)
        而对象分配在堆空间.
 
        栈的特点: 空间相对较小. 但是存储在栈中的数据访问的效率更高一些.
        堆的特点: 空间相对较大. 但是存储在堆中的数据访问的效率相对要低
 
        存储在栈中的数据访问效率高 存储在堆中的数据访问效率低.
 
    3). 赋值.
 
        结构体 Student
        类:   Person
 
        Student s1 = {"jack",19,GenderMale};
        Student s2 = s1;
 
        Person *p1 = [Person new];
        Person *p2 = p1;
 
 
 
 
 3. 应用场景.
 
    1). 如果表示的这个实体 不仅是由多个数据组成, 这个是实体还有行为,不解释只能使用类.
 
 
    2). 如果表示的实体没有行为.光有属性.
 
        a. 如果属性较少.只有几个. 那么这个时候就定义为结构体 分配在栈 提高效率.
 
        b. 如果属性较多.不要定义成结构体. 因为这样结构体变量会在栈中占据很大1块空间 
           反而会影响效率. 
           定义为类.

----------------------------------华丽的分割线--------------------------- 
1. 内存中的五大区域.
 
     栈
     堆
     BSS段
     数据段
     代码段.
 
     代码段:是用来存储代码的. 
 
     类加载. 当类第1次被访问的时候 这个类就会被加载到代码段存储起来.
 
 
  2. 讨论三个问题
 
     1). 类什么时候加载到代码段.
         类第1次被访问的时候,类就会被加载到代码段存储 类加载.
 
     2). 类以什么样的形式存储在代码段.
 
 
     3). 类一旦被加载到代码段之后 什么时候回收.
         是不会被回收的 除非程序结束.
 
 
  3. 类是以什么样的形式存储在代码段的.
 
     1). 任何存储在内存中的数据都有1个数据类型.
 
          int num = 12;
          float  12.12f
          'a'
 
         任何在内存中申请的空间也有自己的类型.
 
         Person *p1 = [Person new];
 
 
     2). 在代码段存储类的那块空间是个什么类型的.
 
         在代码段中存储类的步骤
 
         a. 先在代码段中创建1个Class对象, Class是Foundation框架中的1个类.
            这个Class对象就是用来存储类信息的.
 
         b. 将类的信息存储在这个Class对象之中.
 
            这个Class对象.至少有3个属性
            类名: 存储的这个类的名称.
            属性s: 存储的这个类具有哪些属性
            方法s: 存储的这个类具有哪些方法.
 
 
         所以.类是以Class对象的形式存储在代码段的.
         存储类的这个Class对象 我们也叫做类对象. 用来存储类的1个对象.
 
         所以,存储类的类对象也有1个叫做isa指针的属性 这个指针指向存储父类的类对象.
    
  4. 如何拿到存储在代码段中的类对象.
 
     1). 调用类的类方法 class 就可以得到存储类的类对象的地址.
 
 
     2). 调用对象的对象方法 class 就可以得到存储这个对象所属的类的Class对象的地址.
 
        
     3). 对象中的isa指针的值其实就是代码段中存储类的类对象的地址.
 
     注意:
     声明Class指针的时候 不需要加* 因为在typedef的时候已经加了*了.
 
 
 5. 如何使用类对象.
 
    1). 拿到存储类的类对象以后.
        Class c1 = [Person class];
        c1对象就是Person类.
        c1 完全等价于 Person
 
 
    2). 使用类对象来调用类的类方法.
 
        因为类对象就代表存储在这个类对象中类.
        Class c1 = [Person class];
        c1就代表Person类.
 
        所以在使用Person的地方完全可以使用c1代替.
 
        比如我们使用类名来调用类方法.
        [Person sayHi];
        完全可以使用c1来调用. 因为c1就是Person
        [c1 sayHi];
 
 
    3). 可以使用类对象来调用new方法 创建存储在类对象中的类的对象.
 
        Person *p1 = [Person new];
 
        Class c1 = [Person class];
        其实创建Person对象 也可以这么做.
 
        Person *p2 = [c1 new];
 
 
     4).注意:
        使用类对象 只能调用类的类方法,因为类对象就等价于存在其中的类.
 
         Class c1 = [Person class];
 
         c1就是Person。

 -------------------------------
 
 1.  类是以Class对象的形式存储在代码段之中的.
 
 
 2.  如何拿到存储类的类对象.
 
 
 3.  有神马用?
     可以使用类对象调用类的类方法.
 
     Class c1 = [Person class];
 
     要调用Person的类方法 可以使用Person去调用.
     也可以使用c1去调用.

----------------------------------华丽的分割线--------------------------- 
 1. SEL 全称叫做  selector 选择器.
     SEL 是1个数据类型. 所以要在内存中申请空间存储数据.
     SEL其实是1个类. SEL对象是用来存储1个方法的.
 
 
  2. 类是以Class对象的形式存储在代码段之中.
 
     类名:存储的这个类的类名. NSString 
 
     还要将方法存储在类对象之中.如何将方法存储在类对象之中.
 
     1). 先创建1个SEL对象.
     2). 将方法的信息存储在这个SEL对象之中.
     3). 再将这个SEL对象作为类对象的属性.
 
 
  3. 拿到存储方法的SEL对象.
 
     1). 因为SEL是1个typedef类型的 在自定义的时候已经加*了.
         所以 我们在声明SEL指针的时候 不需要加*
 
     2). 取到存储方法的SEL对象,
         SEL s1 = @selector(方法名);
 
 
  4. 调用方法的本质.
    
      [p1 sayHi];
      内部的原理:
      1). 先拿到存储sayHi方法的SEL对象，也就是拿到存储sayHi方法的SEL数据. SEL消息.
 
      2). 将这个SEL消息发送给p1对象.
 
      3). 这个时候,p1对象接收到这个SEL消息以后 就知道要调用方法
 
      4). 根据对象的isa指针找到存储类的类对象.
 
      5). 找到这个类对象以后 在这个类对象中去搜寻是否有和传入的SEL数据相匹配的.
          如果有 就执行  如果没有再找父类 直到NSObject
 
 
      OC最重要的1个机制:消息机制.
      调用方法的本质其实就是为对象发送SEL消息.
      [p1 sayHi]; 为p1对象发送1条sayHi消息.
 
  5. 重点掌握:
     1).方法是以SEL对象的形式存储起来.
     2).如何拿到存储方法的SEL对象.
 
 
 
  6. 手动的为对象发送SEL消息.
 
     1). 先得到方法的SEL数据.
 
     2). 将这个SEL消息发送给p1对象.
 
         调用对象的方法 将SEL数据发送给对象.
         - (id)performSelector:(SEL)aSelector;
 
        Person *p1 = [Person new];
        SEL s1 = @selector(sayHi);
        [p1 performSelector:s1]; 与 [p1 sayHi]效果是完全一样的.
 
 
     3). 调用1个对象的方法有两种.
       1). [对象名 方法名];
 
       2). 手动的为对象发送SEL消息.
 
 
  7. 注意事项:
 
 
     1). 如果方法有参数 那么方法名是带了冒号的.
      
     2). 如果方法有参数,如何传递参数.
         那么就调用另外1个方法.
 
 - (id)performSelector:(SEL)aSelector withObject:(id)object;
 - (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2;
 
 
     3). 如果有多个参数 
 
 ---------------------------------
 
 1. 类是以Class对象的形式存储在代码段.
 
 2. 如何取到存储类的类对象.
 
 3. 如何使用类对象调用类的类方法 
 
 4. 方法是以SEL数据的形式存储的.
 
 5. 调用方法的两种方式.
 
 
   顿悟.

----------------------------------华丽的分割线--------------------------- 
1. Java、 C# 对象可以使用点语法来访问对象的成员.
     OC中也有点语法. OC中也可以使用点语法来访问对象的属性.
     但是OC的点语法和Java C# 是完全不一样的.
 
 
     OC的对象如果要为属性赋值或者取值 就要调用对应的getter或者setter.
 
 
  2. 使用点语法来访问对象的属性.
 
     语法:
     对象名.去掉下划线的属性名;
     p1.name = @"jack"; 这个时候就会将@"jack"赋值给p1对象的_name属性.
     NSString *name = p1.name; 把p1对象的_name属性的值取出来.
 
 
  3.点语法的原理.
    
    p1.age = 18;
    这句话的本质并不是把18直接赋值给p1对象的_age属性.
 
    点语法在编译器编译的时候.其实会将点语法转换为调用setter、getter的代码.
 
 
    1). 当使用点语法赋值的时候. 这个时候编译器会将点语法转换为调用setter方法的代码.
 
        对象名.去掉下划线的属性名 = 数据;
        转换为:
 
        [对象名 set去掉下划线的属性名首字母大写:数据];
 
        p1.age = 10;
        [p1 setAge:10];
 
 
    2).当使用点语法取值的时候.这个时候编译器会将点语法转换为调用getter方法的代码.
 
        对象名.去掉下划线的属性名;
        转换为:
        [对象名 去掉下划线的属性名];
 
        int age = p1.age;
        int age = [p1 age];
 
 
  4.注意.
 
    1). 在getter和setter中慎用点语法,因为有可能会造成无限递归 而程序崩溃,
 
 
    2). 点语法在编译器编译的时候 会转换为调用setter getter方法的代码.
        p1.name = @"jack";
        [p1 setName:@"jack"]

        NSString *name = p1.name;
        NSString *name = [p1 name];
 
        如果我们的setter方法和getter方法名不符合规范 那么点语法就会出问题.
 
    3). 如果属性没有封装getter setter 是无法使用点语法的 
        因为点语法的本质是getter setter方法.

----------------------------------华丽的分割线--------------------------- 
1. 我们写1个类.
     a. 要先为类写属性.
     b. 在声明属性的getter setter
     c. 再实现getter setter
 
     哎! 1点点技术含量都没有.有没有更为简单的方式来实现同样的代码效果呢
 
 
  2. @property
 
     1). 作用: 自动生成getter、setter方法的声明.
              因为是生成方法的声明,所以应该写在@interface类的声明之中.
    
     2). 语法:
         @property 数据类型 名称;
         @property int age;
 
     3). 原理:
         编译器在编译的时候.会根据@property生成getter和setter方法的实现.
 
         @property 数据类型 名称;
         生成为:
         - (void)set首字母大写的名称:(数据类型)名称;
         - (数据类型)名称;
 
         @property int age;
         - (void)setAge:(int)age;
         - (int)age;
 
  3. 使用@property注意.
 
     1). @property的类型和属性的类型一致.
         @property的名称和属性的名称一致(去掉下划线)
         不要乱写.
 
     2). @property的名称决定了生成的getter和setter方法的名称.
           所以,@property的名称要和属性的名称一致 去掉下划线  否则生成的方法名就是不符合规范的
         @property的数据类型决定了生成的setter方法的参数类型 和 getter方法的返回值类型.
 
 
     3). @property只是生成getter和setter方法的声明. 实现还要自己来. 属性还要自己定义.

----------------------------------华丽的分割线--------------------------- 
 1. @property 只能生成getter和setter的声明.
     实现还要我们自己来.
    
     而实现也是没有什么任何技术含量. 方法实现的代码能不能也可以自动生成呢?
 
 
  2. @synthesize
 
     1).作用: 自动生成getter、setter方法的实现.
             所以,应该写在类的实现之中.
 
     2).语法: 
             @synthesize @property名称;
 
         @interface Person : NSObject
         {
             int _age;
         }
         @property int age;
         @end
        ----------------    
         @implmentation Person
 
         @synthesize age;
         @end
 
 
     3).@synthesize做的事情.
       @implmentation Person
     
       @synthesize age;
       @end
 
       -----------
       @implementaion Person
       {
          int age;
       }
 
       - (void)setAge:(int)age
       {
           self->age = age;
       }
       - (int)age
       {
           return age;
       }
       @end
 
 
 
        a.  生成1个真私有的属性.属性的类型和@synthesize对应的@property类型一致.
            属性的名字和@synthesize对应的@property名字一致.
 
        b.  自动生成setter方法的实现.
            实现的方式: 将参数直接赋值给自动生成的那个私有属性.并且没有做任何的逻辑验证.
 
        c.  自动生成getter方法的实现.
            实现的方式: 将生成的私有属性的值返回.
 
 3. 希望@synthesize不要去自动生成私有属性了.
    getter setter的实现中操作我们已经写好的属性就可以了.
 
    语法:
 
    @synthesize @property名称 = 已经存在的属性名;
 
    @synthesize age = _age;
    1). 不会再去生成私有属性.
 
    2). 直接生成setter getter的实现,
 
        setter的实现: 把参数的值直接赋值给指定的属性.
        gettter的实现: 直接返回指定的属性的值.
 
 
 
 4. 注意:
 
    1). 如果直接写1个@synthesize
        @synthesize name;
 
    2). 如果指定操作的属性.
        @synthesize name = _name;
 
    3). 生成的setter方法实现中 是没有做任何逻辑验证的 是直接赋值.
        生成的getter方法的实现中 是直接返回属性的值.
 
 
         如果setter或者getter有自己的逻辑验证 那么就自己在类的实现中重写就可以了.
 
 
 5. 批量声明
 
    1). 如果多个@property的类型一致. 可以批量声明.
 
        @property float height,weight;
 
 
    2). @synthesize也可以批量声明.
        @synthesize name = _name,age = _age,weight = _weight,height = _height;

----------------------------------华丽的分割线--------------------------- 
 1. @property只是生成getter  setter 的声明.   
     @synthesize是生成getter  setter 的实现.
    
    
     这种写法是Xcode4.4之前的写法. 从Xcode4.4以后.Xcode对@property做了1个增强
 
 
  2. @property增强
 
     只需要写1个@property 编译器就会自动
     
     1) 生成私有属性.
     2).生成getter setter的声明.
     3).生成getter setter的实现.
 
 
     @property NSString *name;
 
     做的事情
     1). 自动的生成1个私有属性,属性的类型和@property类型一致 属性的名称和@property的名称一致 属性的名称自动的加1个下划线.
 
     2). 自动的生成这个属性的getter setter方法的声明
 
     3). 自动的生成这个属性的getter setter方法的实现.
 
         setter的实现: 直接将参数的值赋值给自动生成的私有属性.
         getter的实现: 直接返回生成的私有属性的值.
 
 
  3.使用注意.
 
    1). @property的类型一定要和属性的类型一致. 
        名称要和属性的名称一致 只是去掉下划线.
 
 
    2). 也可以批量声明相同类型的@property
 
 
    3). @property生成的方法实现没有做任何逻辑验证.
 
        setter: 直接赋值
        getter： 直接返回.
 
        所以,我们可以重写setter来自定义验证逻辑.如果重写了setter 还会自动生成getter
        如果重写了getter 还会自动生成setter 
 
 
        如果同时重写getter setter 那么就不会自动生成私有属性了.
 
  
   4. 如果你想为类写1个属性 并且为这个属性封装getter setter
      1个@property就搞定.
 
 
   5. 继承.
      父类的@property一样可以被子类继承.
      @property生成的属性是私有的 在子类的内部无法直接访问生成的私有属性。
      但是可以通过setter getter来访问。

----------------------------------华丽的分割线--------------------------- 
1. OC是1门弱语言.
 
     编译器在编译的时候.语法检查的时候没有那么严格.
     不管你怎么写都是可以的.
 
     int num = 12.12;
 
     优点: 灵活 咋个行都写.
     缺点: 太灵活
 
     强类型的语言: 编译器在编译的时候 做语法检查的时候 行就是行 不行就是不行.
 
 
  2. 静态类型:
     指的是1个指针指向的对象是1个本类对象.
     动态类型:
     指的是1个指针指向的对象不是本类对象.
 
 
 
  3. 编译检查.
  
     编译器在编译的时候,能不能通过1个指针去调用指针指向的对象的方法.
 
     判断原则: 看指针所属的类型之中是有这个方法,如果有就认为可以调用 编译通过.
              如果这个类中没有 那么编译报错.
 
     这个叫做编译检查. 在编译的时候 能不能调用对象的方法主要是看指针的类型.
 
     我们可以将指针的类型做转换,来达到骗过编译器的目的.
 
 
 
  4. 运行检查.
 
     编译检查只是骗过了编译器. 但是这个方法究竟能不能执行.
 
     所以在运行的时候.运行时会去检查对象中是否真的有这个方法.如果有就执行 如果没有就报错误.
 
 
  5. LSP
     父类指针指向子类对象.
 
     实际上任意的指针可以执行任意的对象.编译器是不会报错的.
 
     当1个子类指针执行1个父类对象的时候,编译器运行通过子类指针去调用子类独有的方法.
     但是在运行的时候是会出问题的.因为父类对象中根本没有子类成员.

----------------------------------华丽的分割线--------------------------- 
 1. NSObject.
     是OC中所有类的基类.根据LSP NSObject指针就可以指向任意的OC对象.
     所以.NSObject指针是1个万能指针.可以执行任意的OC对象.
    
     缺点: 如果要调用指向的子类对象的独有的方法.就必须要做类型转换.
 
 
  2. id指针.
     是1个万能指针,可以指向任意的OC对象.
 
     1). id是1个typedef自定义类型 在定义的时候已经加了*
         所以,声明id指针的时候不需要再加*了.
 
     2)  id指针是1个万能指针,任意的OC对象都可以指.
 
 
  3. NSObject和id的异同.
 
     相同点: 万能指针 都可以执行任意的OC对象.
 
     不同点: 通过NSObject指针去调用对象的方法的时候.编译器会做编译检查.
            通过id类型的指针去调用对象的方法的时候,编译器直接通过.无论你调用什么方法.
 
     
     注意: id指针只能调用对象的方法  不能使用点语法.如果使用点语法就会直接报编译错误 。
     如果我们要声明1个万能指针 千万不要使用NSObject 而是使用id
 
  4. 父类中的类方法创建1个父类对象返回.
 
     1). 如果返回值写为父类类型的.那么子类来调用这个方法得到的就是父类指针.
         解决的方式: 把返回值改为id类型的.
 
     2). 方法的内部创建的对象的是 不要写死. 因为写死创建的对象就固定了.
         我们希望那1个类来调用这个方法就创建那1个类的对象.
 
         把类名写为self 那1个类来调用这个方法 self就指的是那1个类.创建的就是那1个类的对象.
 
     3). 方法的返回值是id类型的.问题就是任意指针都可以接收这个方法的返回值.
         编译器连个警告都没有.
 
         如果方法的返回值是instancetype
         代表方法的返回值是当前这个类的对象.
 
 
 
     5). 使用建议
 
         1). 如果方法内部是在创建当前类的对象,不要写死成类名 【类名 new】;
             而是用self代替类名.
 
         2). 如果方法的返回值是当前类的对象,也不要写死了. 而是写instancetype
 
 
 
     6). id和instancetype的区别.
 
         1).instancetype只能作为方法的返回值.不能在别的地方使用.
            id既可以声明指针变量 也可以作为参数 也可以作为返回值.
 
         2). instancetype 是1个有类型的 代表当前类的对象.
            id是1个无类型的指针 仅仅是1个地址.没有类型的指针.

----------------------------------华丽的分割线--------------------------- 

1. 编译检查.
 
     编译器在编译的时候. 判断1个指针是否可以调用指向的对象的方法.
     判断的准则就是指针的类型.
 
     LLVM
 
     我们可以很轻松的把编译器给骗过.
 
 
  2. 就算骗过了编译器,程序在运行的时候还会做运行检查.
     我们写的程序就算编译通过了.不意味着可以完美的执行.
 
 
  3. 我们就希望.我们可以写代码来先判断1下.对象中是否有这个方法.如果有再去执行.
     如果没有就别去执行.
 
 
     1). 判断对象中是否有这个方法可以执行.
 
         - (BOOL)respondsToSelector:(SEL)aSelector;
 
         最常用的是这个方法. 
 
         Person *p1 = [Person new];
         [p1 sayHi];
 
 
 
     2). 判断类中是否有指定的类方法.
 
         + (BOOL)instancesRespondToSelector:(SEL)aSelector;
 
 
     2). 判断指定的对象是否为 指定类的对象或者子类对象.
        - (BOOL)isKindOfClass:(Class)aClass;
 
        BOOL b1 = [s1 isKindOfClass:[Person class]];

        判断s1对象是否为Person对象或者Person的子类对象.
 
 
     3). 判断对象是否为指定类的对象 不包括子类.
 
         - (BOOL)isMemberOfClass:(Class)aClass;
         [s1 isMemberOfClass:[Student class]];
         判断s1对象是否为1个Student对象. 不包括Student的子类对象.
 
     4). 判断类是否为另外1个类的子类.
        + (BOOL)isSubclassOfClass:(Class)aClass;
----------------------------------华丽的分割线--------------------------- 
 1. 创建对象,我们之前说:
        
     类名 *指针名 =  [类名  new];
 
     new实际上是1个类方法.
 
     new方法的作用:
     -> 创建对象。
     -》 初始化对象
     -> 把对象的地址返回.
 
 
     new方法的内部,其实是先调用的alloc方法. 再调用的init方法.
 
     alloc方法是1个类方法,作用: 那1个类调用这个方法 就创建那个类的对象,并把对象返回.
     init方法 是1个对象方法,作用: 初始化对象.
 
     创建对象的完整步骤:
     应该是先使用alloc创建1个对象,然后再使用init初始化这个对象 才可以使用这个对象.
     虽然没有初始化的对象 有的时候 也可以使用. 但是千万不要这么做.
     使用1个未经初始化的对象是极其危险的.
 
     Person *p1 = [Person new];
     完全等价于
     Person *p1 = [[Person alloc] init];
 
     
  2. init方法.
 
     作用: 初始化对象,为对象的属性赋初始值 这个init方法我们叫做构造方法.
 
          init方法做的事情:初始化对象.
          为对象的属性赋默认值.
 
          如果属性的类型是基本数据类型就赋值为0
                        C指针           NULL
                        OC指针          nil
 
     所以.我们创建1个对象如果没有为这个对象的属性赋值 这个对象的属性是有默认值的.
     所以,我们每次新创建1个对象,这个对象的属性都被初始化了.
 
 
  3. 我们想要让创建的对象的属性的默认值不是 nil NULL 0
     而是我们自定义的.
     那么这个时候,我们就可以重写init方法. 在这个方法中按照我们自己的想法为对象的属性赋值.
 
     重写init方法的规范:
     1). 必须要先调用父类的init方法.然后将方法的返回值赋值给self
 
     2). 调用init方法初始化对象有可能会失败,如果初始化失败.返回的就是nil
 
     3). 判断父类是否初始化成功. 判断self的值是否为nil 如果不为nil说明初始化成功.
 
     4). 如果初始化成功 就初始化当前对象的属性.
 
     5). 最后 返回self的值.
 
 
     解惑
     1). 为什么要调用父类的init方法.
         因为父类的init方法 会初始化父类的属性. 所以必须要保证当前对象中的父类属性也同时被初始化.
 
     2). 为什么要赋值给self？
         因为.调用父类的init方法 会返回初始化成功的对象
         实际上返回的就是当前对象。但是我们要判断是否初始化成功.
 
     无论如何,记住重写init方法的规范.
 
     - (instancetype)init
     {
         if(self = [super init])
         {
            //初始化当前类的属性的代码;
         }
         retrun self;
     }
 
     什么时候需要重写init方法:
     如果你希望创建出来的对象的属性的默认值不是 nil NULL 0 而是我们指定的值.
     那么这个时候我们就可以重写init方法.
 
 
 
 3.  重写init方法以后.
     稍稍不爽的: 这样每次创建出来的对象的属性的值都是一样的.
 
     创建对象的时候,对象的属性的值由创建对象的人来指定.而不是写死在init方法中
 
 
     自定义构造方法.
 
     规范:
     1). 自定义构造方法的返回值必须是instancetype
     2). 自定义构造方法的名称必须以initWith开头.
     3). 方法的实现和init的要求一样.
 
 
     什么时候要自定义构造方法?


----------------------------------华丽的分割线--------------------------- 
 1. Xcode4.4之前
     @property: 只生成getter、setter方法的声明.
     @synthesize: 生成私有属性.并生成getter、setter方法的实现.
 
 
     Xcode4.4开始.
     @property增强: 
     1). 自动生成私有属性.
     2). 自动生成私有属性的getter setter方法的声明和实现.
 
 
  2. 编译检查与运行检查
 
     编译检查: 
     通过1个指针去访问对象的成员的时候,编译判断可以不可以的准则: 指针的类型当中是否有这个成员.
     运行检查:
     在程序运行的时候,通过1个指针去访问对象的成员之前,还会检查指针所指向的对象中是否真的有这个成员.
 
  
  3. 万能指针(NSObject、id). instancetype
 
     NSObject和id 它们都是万能指针,可以指向任意的OC对象.
     NSObject指针访问对象的成员的时候,编译器会做编译检查.
     id指针调用指针指向的对象的方法的时候.编译器不做任何检查 直接通过.
 
     id指针的缺点: 不能使用->访问属性 也不能使用点语法.
 
     instancetype: 只能做为方法的返回值.代表返回当前类的对象.
 
 
  4. 动态类型检测 反射
 
     1). 判断指针指向的对象中 指定的方法是是否可以调用.
 
     2). 判断类方法是否可以调用.
 
     3). 判断对象是否为指定类的对象或者子类对象.
 
     4). 判断对象是否为指定类的对象.
 
     5). 判断指定的类是否为另外1个类的子类.
 
  5. 构造方法.
     1). new是1个类方法. 创建对象初始化对象返回对象.
     2). new方法的内部其实就是 alloc init
     3). init方法就叫做构造方法. 初始化对象
     4). 重写init构造方法.     
     5). 自定义构造方法.
         
 
    如果你想要调用init默认的构造方法.那么new可以. 也可以使用alloc init
    如果你像要调用自定义的构造方法.这个时候就必须先alloc 再调用自定义的init

----------------------------------华丽的分割线--------------------------- 
 1. 内存管理
     内存的作用:存储数据.
 
     1). 如何将数据存储到内存之中.
         声明1个变量.然后将数据存储进去.
 
     2). 当数据不再被使用的时候,占用的内存空间如何被释放.
 
 
  2. 内存中的五大区域
 
     栈: 局部变量. 当局部变量的作用域被执行完毕之后,这个局部变量就会被系统立即回收.
     堆: OC对象.使用C函数申请的空间.
     BSS段: 未初始化的全局变量、静态变量. 一旦初始化就回收 并转存到数据段之中.
     数据段: 已经初始化的全局变量、静态变量. 直到程序结束的时候才会被回收.
     代码段: 代码. 程序结束的时候,系统会自动回收存储在代码段中的数据.
 
     栈、BSS段、数据段、代码段存储在它们中的数据的回收,是由系统自动完成的.不需要我们干预.
 
 
  3. 分配在堆区中的OC对象,是肯定需要被回收的.
 
     iPhone 内存机制.
 
     40M 警告
     45M 警告
     120M 闪退.
 
     存储在堆中的OC对象,系统不会自动回收. 直到程序结束的时候才会被回收.
 
 
  4. 内存管理的范围:
     只需要管理存储在堆中的OC对象的回收.其他区域中的数据的回收是系统自动管理的.
 
 
  5. 对象应该什么时候被回收?
 
     当有人使用这个对象的时候,这个对象就千万不能回收.
     只有在没有任何人使用这个对象的时候,才可以回收.
 
 
  6. 引用计数器
     
     1). 每1个对象都有1个属性.叫做retainCount.叫做引用计数器. 类型是unsigned long 占据8个字节.
         引用计数器的作用: 用来记录当前这个对象有多少个人在使用它.     
         默认情况下,创建1个对象出来 这个对象的引用计数器的默认值是1.
 
     2). 当多1个人使用这个对象的时候.应该先让这个对象的引用计数器的值+1 代表这个对象多1个人使用.
 
     3). 当这个对象少1个人使用的时候.应该先让这个对象的引用计数器的值-1 代表这个对象少1个人使用.
 
     4). 当这个对象的引用计数器变为0的时候.代表这个对象无人使用. 这个时候系统就会自动回收这个对象.
 
 
  7. 如何操作引用计数器.
 
     1). 为对象发送1条retain消息. 对象的引用计数器就会加1. 当多1个人使用对象的时候才发.
 
     2). 为对象发送1条release消息.对象的引用计数器就会减1. 当少1个人使用对象的时候才发.
 
     3). 为对象发送1条retainCount消息. 就可以去到对象的引用计数器的值.
 
     就这样++ -- 当对象的引用计数器变为0的时候,对象就会被系统立即回收.
 
     在对象被回收的时候.会自动调用对象的dealloc方法.
 
 
 
  8. 内存管理的分类
 
     MRC: Manual Reference Counting 手动引用计数.手动内存管理.
 
          当多1个人使用对象的时候,要求程序员手动的发送retain消息.少1个人使用的时候程序员手动的发送relase消息.
 
     2011年之前 iOS5之前
     ARC: Automatic Reference Counting  自动引用计数.自动内存管理.
          系统自动的在合适的地方发送retain relase消息.
 
 
     我们今天学习的MRC.
     学习MRC的理由:
     1). 面试必考 100%
     2). 早期的APP开发使用的MRC技术.
     3). iOS大牛都是从MRC成长起来的. 方便交流.
     4). ARC是基于MRC

----------------------------------华丽的分割线--------------------------- 
 1. iOS5开始. Xcode4.2开始就支持ARC
     Xcode7 默认支持ARC开发.
     默认使用的开发方式就是ARC的模式.
 
     关闭ARC开启MRC.
 
 
  2. 当对象的引用计数器变为0的时候,系统会自动回收对象.
     在系统回收对象的时候.会自动的调用对象的dealloc方法.
 
     重写dealloc方法的规范:
     必须要调用父类的dealloc方法. 并且要放在最后一句代码.
 
 
  3. 测试引用计数器.
 
     1). 新创建1个对象,这个对象的引用计数器的值默认是1.
     2). 当对象的引用计数器变为0的时候.对象就会被系统立即回收 并自动调用dealloc方法.
     3). 为对象发送retain消息 对象的引用计数器就会+1
 
 
 
 
  4. 为对象发送release消息.并不是回收对象.而是让对象的引用计数器-1
     当对象的引用计数器的值变为0的时候.对象才会被系统立即回收.

----------------------------------华丽的分割线--------------------------- 
 1. 内存管理的重点
 
     1). 什么时候为对象发送retain消息.
 
         当多1个人使用这个对象的时候,应该先为这个对象发送retain消息.
 
     2). 什么时候为对象发送releaee消息.
 
         当少1个人使用这个对象的时候.应该为这个对象发送1条release消息.
 
 
  
  2. 在ARC机制下,retain release dealloc这些方法方法无法调用.
 
 
 
  2. 内存管理的原则
     1). 有对象的创建,就要匹配1个release
 
     2). retain的次数和release的次数要匹配.
 
     3). 谁用谁retain. 谁不用谁release.
         谁负责retain 谁就负责relase
 
     4). 只有在多1个人用的时候才retain 少1个人使用的时候才release
 
 
     有始有终,有加就有减. 有retain就应该匹配1个release 一定要平衡.

----------------------------------华丽的分割线--------------------------- 
 1. 野指针
 
     C语言中的野指针: 定义1个指针变量.没有初始化.这个指针变量的值是1个垃圾值,指向1块随机的空间.这个指针就叫做野指针.
 
     OC中的野指针: 指针指向的对象已经被回收了.这样的指针就叫做野指针.
 
 
  2. 对象回收的本质.
     
     内存回收的本质: 
     申请1个变量,实际上就是向系统申请指定字节数的空间.这些空间系统就不会再分配给别人了.
     当变量被回收的时候,代表变量占用的字节空间从此以后系统可以分配给别人使用了.
     但是字节空间中存储的数据还在.
 
 
     回收对象:
     所谓的对象的回收,指的是对象占用的空间可以分配给别人.
     当这个对象占用的空间没有分配给别人之前 其实对象数据还在.
 
 
 
 3. 僵尸对象
    1个已经被释放的对象,但是这个对象所占的空间还没有分配给别人.这样的对象叫做僵尸对象.
 
    我们通过野指针去访问僵尸对象的时候.有可能没问题 也有可能有问题.
 
    当僵尸对象占用的空间还没有分配给别人的时候.这是可以的.
    当僵尸对象占用的空间分配给了别人使用的时候 就不可以.
 
 
 4. 我们认为只要对象称为了僵尸对象,无论如何 都不允许访问了.
    就希望如果访问的是僵尸对象,无论如何报错.
 
    僵尸对象的实时检查机制.可以将这个机制打开. 打开之后. 只要访问的是僵尸对象,无论空间是否分配 就会报错.
 
 
 5. 为什么不默认打开僵尸对象检测.
 
    一旦打开僵尸对象检测 那么在每访问1个对象的时候 都会先检查这个对象是否为1个僵尸对象,
    这样是极其消耗性能的.
 
 6. 使用野指针访问僵尸对象会报错. 如何避免僵尸对象错误..
 
    当1个指针称为野指针以后.将这个指针的值设置nil
 
    当1个指针的值为nil 通过这个指针去调用对象的方法(包括使用点语法)的时候.不会报错. 只是没有任何反应.
                     但是如果通过直接访问属性 -> 就会报错.
 
 
 
 7. 无法复活1个僵尸对象.
    
 
 
 僵尸对象到底能不能用

----------------------------------华丽的分割线--------------------------- 
1. 内存泄露.
     
     指的是1个对象没有被及时的回收.在该回收的时候而没有被回收
     一直驻留在内存中,直到程序结束的时候才回收.
 
 
  2. 单个对象的内存泄露的情况.
     
     1). 有对象的创建,而没有对应的relase
 
     2). retain的次数和relase的次数不匹配.
 
     3). 在不适当的时候,为指针赋值为nil
 
     4). 在方法中为传入的对象进行不适当的retain
 
 
  3. 如何保证单个对象可以被回收
 
     1). 有对象的创建 就必须要匹配1个relase
 
     2). retain次数和release次数一定要匹配.
 
     3). 只有在指针称为野指针的时候才赋值为nil
 
     4). 在方法中布要随意的为传入的对象retain.

----------------------------------华丽的分割线--------------------------- 
 用面向对象模拟1个案例:
   
  凤姐开车去拉萨.
 
 
  人类:
    属性: 车.
    行为: 开车.
 
 

  车类:
    属性: 速度.
    行为: 行驶.
 

 
 
 
 
  1. 当属性是1个OC对象的时候. setter方法的写法.
 
     将传进来的对象赋值给当前对象的属性,代表传入的对象多了1个人使用,所以我们应该先为这个传入的对象发送1条retain消息 再赋值.
 
     当当前对象销毁的时候.代表属性指向的对象少1个人使用. 就应该在dealloc中relase
 
 
     代码写法:
 
     - (void)setCar:(Car *)car
     {
        _car = [car retain];
     }
 
 
     - (void)dealloc
     {
        [_car release];
        [super dealloc];
     }
 
 
 
  2. 当属性是1个OC对象的时候,setter方法照着上面那样写,其实还是有Bug的.
     当为对象的这个属性多次赋值的时候.就会发生内存泄露.
     发生泄露的原因: 当为属性赋值的时候, 代表旧对象少1个人用.新对象多1个人使用.
     应该relase旧的 retain新的.
 
 
     - (void)setCar:(Car *)car
     {
         [_car release];
         _car = [car retain];
     }

----------------------------------华丽的分割线--------------------------- 
1. 在MRC的开发模式下.1个类的属性如果是1个OC对象类型的.那么这个属性的setter方法就应该按照下面的格式写.
    
     - (void)setCar:(Car *)car
     {
         if(_car != car)
         {
            [_car release];
            _car = [car retain];
         }
     }
 
     还要重写dealloc方法.
     - (void)dealloc
     {
        [_car release];
        [super delloc];
     }
 
     如果属性的类型不是OC对象类型的.不需要像上面那样写. 还是像之前那样写就OK了.
 
 
  2. @property
 
     1). 作用
         a. 自动生成私有属性.
         b. 自动生成这个属性的getter setter方法的声明.
         c. 自动生成这个属性的getter setter方法的实现.
 
         特别播报:
         生成的setter方法的实现中,无论是什么类型的,都是直接赋值.
 
 
 
  3. @property参数.
 
     1). @property可以带参数的.
         @property(参数1,参数2,参数3......)数据类型 名称;
 
 
     2). 介绍一下@property的四组参数.
 
         a. 与多线程相关的两个参数.
            atomic、nonatomic.
 
         b. 与生成的setter方法的实现相关的参数.
            assign、retain.
 
         c. 与生成只读、读写相关的参数       
            readonly readwrite
 
         d. 是与生成的getter setter方法名字相关的参数.
            getter  setter
 
 
 
  4. 介绍与多线程相关的参数.
 
     atomic: 默认值. 如果写atomic,这个时候生成的setter方法的代码就会被加上一把线程安全锁.
             特点: 安全、效率低下.
     nonatomic: 如果写nonatomic 这个时候生成的setter方法的代码就不会加线程安全锁.
             特点: 不安全,但是效率高.
 
     建议: 要效率. 选择使用nonatomic  在没有讲解多线程的知识以前 统统使用nonatomic
 
 
 
  5. 与生成的setter方法的实现相关的参数.
 
     assign: 默认值 生成的setter方法的实现就是直接赋值.
 
     retain: 生成的setter方法的实现就是标准的MRC内存管理代码.
             也就是. 先判断新旧对象是否为同1个对象 如果不是 release旧的   retain新的.
 
     当属性的类型是OC对象类型的时候,那么就使用retain
     当属性的类型是非OC对象的时候,使用assign.
 
     千万注意:
     retain参数.只是生成标准的setter方法为标准的MRC内存管理代码 不会自动的再dealloc中生成relase的代码.
     所以, 我们还要自己手动的在dealloc中release
 
 
 
  6. 与生成只读、读写的封装.
 
     readwrite: 默认值.代表同时生成getter setter
     readonly: 只会生成getter 不会生成setter
  
 
 
  7. 生成getter、setter方法名称相关的参数.
 
     默认情况下.@property生成的getter setter方法的名字都是最标准的名字.
     其实我们可以通过参数来指定@property生成的方法的名字.
 
     getter = getter方法名字 用来指定@property生成的getter方法的名字.
     setter = setter方法名字.用来指定@property生成的setter方法的名字. 注意.setter方法是带参数的 所以要加1个冒号.
 
     
     记住:如果使用getter setter修改了生成的方法的名字.
          在使用点语法的时候.编译器会转换为调用修改后的名字的代码.
 
     修改生成的getter setter方法名字. 因为默认情况下生成的方法的名字已经是最标准的名字了.
     所以.一般情况下不要去改.
 
 
     1). 无论什么情况都不要改setter方法的名字. 因为默认情况下生成的名字就已经是最标准的了.
     2). 什么时候修改getter方法的名字.当属性的类型是1个BOOL类型的时候.就修改这个getter的名字以is开头 提高代码的阅读性.
 
 
 
 ------总结-------
 
 1. 与多线程相关的参数: 用nonatomic
 2. 与生成的setter方法实现相关的参数
    属性的类型是OC对象的时候 使用retain
    属性的类型是非OC对象的时候 使用assign
 
 3. 只读 读写.  
    如果你希望生成的封装是只读封装  那么就使用readonly
    如果希望读写封装 readwrite
 
 4.  1). 无论什么情况都不要改setter方法的名字. 因为默认情况下生成的名字就已经是最标准的了.
     2). 什么时候修改getter方法的名字.当属性的类型是1个BOOL类型的时候.就修改这个getter的名字以is开头 提高代码的阅读性.
 
 ------使用参数注意-----
 1. 同1组参数只能使用1个.
    getter setter可以同时使用.
 
 2. 参数的顺序可以随意.

----------------------------------华丽的分割线--------------------------- 
 1. 当两个类相互包含的时候. 当Person.h中包含Book.h 而Book.h中又包含Person.h
     这个时候,就会出现循环引用的问题. 就会造成无限递归的问题,而导致无法编译通过.
 
  2. 解决方案: 
     其中一边不要使用#import引入对方的头文件.
     而是使用@class 类名; 来标注这是1个类.这样子就可以在不引入对方头文件的情况下,告诉编译器这是1个类.\\\\    \\\
 
     在.m文件中再#import对方的头文件.就可以使用了.
 
 
  3. @class与#import的区别
 
     1). #import是将指定的文件的内容拷贝到写指令的地方.
 
     2). @class 并不会拷贝任何内容. 只是告诉编译器,这是1个类,这样编译器在编译的时候才可以知道这是1个类.
 

----------------------------------华丽的分割线--------------------------- 
1. 当两个对象相互引用的时候.
     A对象的属性是B对象  B对象的属性是A对象.
     这个时候 如果两边都使用retain 那么就会发生内存泄露.
 
 
  2. 解决方案: 1端使用retain 另外1端使用assign 使用assign的那1端在dealloc中不再需要release了.
 

----------------------------------华丽的分割线--------------------------- 
 3. 出现的僵尸对象错误的原因:
 
      在于.新旧对象是同1个对象.
      解决的方案:  当发现新旧对象是同1个对象的时候.什么都不用做. 
                 只有当新旧对象不是同1个对象的时候 才release旧的 retain新的.
 
 
 
      最终完美版的setter方法的写法 应该这样写
 
      - (void)setCar:(Car *)car
      {
          if(_car != car)
          {
             [_car release];
             _car = [car retain];
          }
      }
 
      - (void)dealloc
      {
         [_car releae];
         [super dealloc];
      }
 
 
  4. 特别注意.
 
     我们每次管理的范围是 OC 对象.
     所以,只有属性的类型是OC对象的时候.这个属性的setter方法才要像上面那样写.
     如果属性不是OC对象类型的 setter方法直接赋值就可以了.

----------------------------------华丽的分割线--------------------------- 
0. 在MRC的模式下,我们只需要管理OC对象. 其他的数据都不需要我们进行管理.
     决定OC对象什么时候被释放.
 
 
  1. MRC下的内存管理原理.
     每1个对象都有1个retainCount属性.叫做引用计数器.
     占据8个字节,类型是unsinged long
     
     引用计数器的作用:用来记录这个对象有多少个人正在使用.
 
     当我们创建1个对象,这个对象的引用计数器为1.
     如果有人使用这个对象,就让这个对象的引用计数器加1. 代表多1个人使用这个对象.
     如果这个人不再使用这个对象,就让这个对象的引用计数器减1.代表少1个人使用这个对象.
     
     当对象的引用计数器为0的时候.系统就会立即回收这个对象,并调用对象的dealloc方法.
 
     关闭ARC的方式.
 
     重点和难点:
     什么时候为对象的引用计数器+1
     什么时候为对象的引用计数器-1
 
  2. 操作引用计数器的方式.
     为对象发送retain消息. 对象的引用计数器就会加1. 这个消息的返回值是对象本身,
     为对象发送release消息,对象的引用计数器就会减1.
     为对象发送retainCount消息,就会返回对象的引用计数器的值.
 
     在对象的引用计数器为0的时候,对象就会被系统立即回收,并调用这个对象的dealloc方法.
 
 
     引用计数器的改变只能调用retain、release,不能直接赋值.
 
  3. 在MRC下,重写dealloc方法的规范.
 
     必须要调用父类的dealloc方法,并且要放在最后调用. 别问为什么.
     为什么? 因为子类中有父类的属性.而父类属性的release是放在父类的dealloc方法之中的.
     为了能够释放所有的对象 必须要调用父类的dealloc方法.
 
  4. 内存管理的原则
     1). 有对象的创建,就必须要匹配1个release.
     2). 只有在多1个人使用的时候,才为对象发送retain消息,只有当少1个人使用的时候才为对象发送release消息.
     3). 谁retain 谁release
     4). retain的次数要和release的次数匹配.
 
     有始有终,有加就应该有减.【曾经让某个对象的引用计数器加1.就应该在不使用这个对象的时候让对象的引用计数器减1】.
 
  5. 野指针与僵尸对象.
     1). 概念
     野指针: 指针指向的对象已经被释放,这个指针就叫做野指针.
     僵尸对象:1个被释放的对象,就叫做僵尸对象.
    
     通过野指针去访问1个僵尸对象的时候.是有可能会出问题的.
    
     对象的回收的本质:
     是对象占用的空间系统可以分配给别的对象.  
     在未被分配给别的程序之前 其实啊这个对象还在的.数据也在的. 但是这块空间随时有可能分配给别的程序.
     
     在未被分配给别的对象之前 其实还是可以访问的
     一旦分配给别人就不能访问了.
 
     僵尸对象就不应该被允许访问 因为被释放了.
      
 
     开启僵尸对象检测.
     
     2). 如何避免使用僵尸对象.
         当指针为野指针的时候,将其赋值为nil.
 
     3). 无法让僵尸对象复活.
 
  6. 单个对象的内存泄露.
     
     1).什么叫做内存泄露?
        指对象没有被回收,该回收的时候而没有被回收,一直驻留在内存之中直到程序结束.  
 
 
     2).单个对象发生内存泄露的原因.
        -> 有对象的创建,没有匹配的release
        -> retain与release不匹配.
        -> 在不恰当的时候,指针赋值为nil
        -> 在方法中不当使用retain.
 
     3).如何做到单个对象被正确释放
        -> 有对象的创建就要有对象的release。
        -> 有多少个retain就要有多少个release。
        -> 不要轻易的为1个指针赋值为nil 除非指针是1个野指针.
        -> 在方法中不要轻易的为参数retain

  7. 多个对象的内存泄露.
     
     演示.人与车.出现的内存泄露.
 
     1). 当1个对象的属性是另外1个对象的适时候,如果对这个属性的set封装还是像我们基础班那样直接赋值.
         这样是会出问题.会出现野指针的问题.
 
  8. set方法的内存管理.
     在MRC的模式下,如果属性的类型是OC对象类型的,这个属性的setter方法应该如何写.
     1). 先retain传入的对象. 赋值给属性.在dealloc中release。
 
     2). 重新赋值1个对象的时候 旧对象无法释放.
         先release旧的对象,再retain新的对象.
 
     3). 当多次赋值同1个对象的时候.就会出现僵尸对象 。
      
  9. @property参数.
 
 
     1). @proerty的作用
         @property int age;
        
         a. 生成1个私有的,int类型的属性_age; 是声明在@implementation的大括弧之中.
         b. 生成getter、setter的声明.
         c. 生成getter、setter的实现,
            setter的实现: 将传递进来的值不做任何操作直接赋值给属性.
 
     2), @property可以带参数. 不同的参数有不同的效果.
 
         a，与多线程相关的.
            atomic: 默认的.
            nonatomic:
 
            选择nonatomic. 因为效率高.
 
 
         b. 和生成的set方法相关的参数.
            retain 生成的set方法就是标准的MRC内存管理代码. 不再是直接赋值了 
                   而是先判断新旧对象是否为同1个对象.如果不时 relase旧的 retain新的.
 
                   retain只是生成的set方法是标准的MRC内存管理代码.  不会自动的在dealloc中release 
                    所以,我们还要在dealloc方法中手动的relase属性指向的对象.
 
 
            assign: 默认值 生成的set方法中不做其他任何操作 直接赋值.
 
 
 
            如果属性的类型是OC对象类型的,那么使用retain
            如果属性的类型是非OC对象类型的 那么使用assign
 
 
         c. 和生成的属性 只读、读写有关的参数.

            readwrite: 默认值,getter setter同时生成.
            readonly: 只生成getter
 
         d. 修改生成getter setter方法的名字.
             
            一般情况下别改, 只在1个地方.
 
            当属性的类型是BOOL类型的时候 就更改getter的名字以is开头.
 
    
  10. @class
 
 
      两个头文件相互包含的时候 如果两边都使用#import来包含 就会出错 就会死循环.
 
      其中1个头文件 不要使用#import指令 而是是@class 类名;
 
      @class Person;
 
      在.m文件中再去#import
 
 
  11. 循环retain
 
      当两个对象相互关联的时候.
 
      人对象中有1个车  
 
      车对象中有1个人.
        
      如果这两个@property都使用retain 就会出现泄漏.
 
      解决方案:  1端retain 1端assign 使用assign的那1端不再需要在dealloc中release了.

----------------------------------华丽的分割线--------------------------- 
 1. 自动释放池的原理.
 
     存入到自动释放池中的对象,在自动释放池被销毁的时候.会自动调用存储在该自动释放池中的所有对象的release方法.
 
     可以解决的问题:
     将创建的对象,存入到自动释放池之中. 就不再需要手动的relase这个对象了.
     因为池子销毁的时候 就会自动的调用池中所有的对象的relase。
 
 
     自动释放池的好处: 将创建的对象存储到自动释放池中,不需要再写release
 
 
  2. 如何创建自动释放池.
 
     @autoreleasepool
     {
 
     }
 
     这对大括弧代表这个自动释放池的范围.
 
  3. 如何将对象存储到自动释放池之中
     
     在自动释放池之中调用对象的autorelease方法.就会将这个对象存入到当前自动释放池之中.
 
     这个autorealse方法返回的是对象本身. 所以,我们可以这么写
        
     @autoreleasepool
     {
        Person *p1 = [[[Person alloc] init] autorelease];
     }
 
     这个时候,当这个自动释放池执行完毕之后,就会立即为这个自动释放池中的对象发送1条release消息.
 
     目前为止,我们感受到得autorelase的好处:
     创建对象,调用对象的autorelase方法 将这个对象存入到当前的自动释放池之中.
 
     我们就不需要再去relase 因为自动释放池销毁的时候 就会自动的调用池中所有对象的relase
 
  4. 使用注意
 
     1). 只有在自动释放池中调用了对象的autorelease方法,这个对象才会被存储到这个自动释放池之中.
         如果只是将对象的创建代码写在自动释放之中,而没有调用对象的autorelease方法.是不会将这个对象存储到这个自动释放池之中的.
 
     2). 对象的创建可以在自动释放池的外面,在自动释放池之中,调用对象的autorelease方法,就可以将这个对象存储到这个自动释放池之中.
 
     3). 当自动释放池结束的时候.仅仅是对存储在自动释放池中的对象发送1条release消息 而不是销毁对象.
 
     4). 如果在自动释放池中,调用同1个对象的autorelease方法多次.就会将对象存储多次到自动释放池之中.
         在自动释放池结束的时候.会为对象发送多条release消息.那么这个是就会出现僵尸对象错误.
         所以,1个自动释放池之中,只autorelease1次,只将这个对象放1次, 否则就会出现野指针错误.
 
     5). 如果在自动释放池中,调用了存储到自动释放中的对象的release方法.
         在自动释放池结束的时候,还会再调用对象的release方法. 
         这个时候就有有可能会造成野指针操作.
    
         也可以调用存储在自动释放池中的对象的retain方法.
 
 
     6). 将对象存储到自动释放池,并不会使对象的引用计数器+1
         所以其好处就是:创建对象将对象存储在自动释放池,就不需要在写个release了.
 
     7).  自动释放池可以嵌套.
          调用对象的autorelease方法,会讲对象加入到当前自动释放池之中
          只有在当前自动释放池结束的时候才会像对象发送release消息.
 
 5. autorelease的规范.
     0). 创建对象,将对象存储到自动释放池之中. 就不需要再去手动的realse。
 
 
     1). 类方法的第1个规范:
         一般情况下,要求提供与自定义构造方法相同功能的类方法.这样可以快速的创建1个对象.
 
 
    
     2). 我们一般情况下,写1个类. 会为我们的类写1个同名的类方法,用来让外界调用类方法来快速的得到1个对象.
         规范:使用类方法创建的对象,要求这个对象在方法中就已经被autorelease过了.
         这样,我们只要在自动释放池中, 调用类方法来创建对象, 那么创建的对象就会被自动的加入到自动释放中.
        
         提供1个类方法来快速的得到1个对象.
         规范
         a. 这个类方法以类名开头. 如果没有参数就直接是类名 如果有参数就是 类名WithXX:
         b. 使用类方法得到的对象,要求这个对象就已经被autorelease过了.
 
         + (instancetype)person
         {
            return [[[self alloc] init] autorelease];
         }
 
         这样,我们直接调用类方法.就可以得到1个已经被autorelease过的对象.
         @autoreleasepool
         {
             Person *p1 = [Person person];
             //这个p1对象已经被autorelase过了.不需要再调用autorelase
             //这个p1对象就被存储到当前自动释放池之中.
         }//当自动释放池结束.就会为存储在其中的p1对象发送release消息.
 
 6. 实际上Apple的框架中的类也是遵守这个规范的.
 
    通过类方法创建的对象都是已经被autorelease过的了.
 
    所以,我们也要遵守这个规范. 类方法返回的对象也要被autorealse过.
 
    以后,我们凡事创建对象是调用类方法创建的对象 这个对象已经是被autorelease过的了.

----------------------------------华丽的分割线--------------------------- 
 在MRC
 一、微博类 (Microblog)
	属性：
* 文字内容
 * 图片
 * 发表时间 (可以用字符串表示NSString)
 * 作者
 * 被转发的微博
 * 评论数
 * 转发数
 * 点赞数
 
 二、作者类 (User)
 * 名称
 * 生日
 * 账号
 三、账号类 (Account)
 * 账号名称
 * 账号密码
 * 账号注册时间 (可以用字符串表示NSString)

----------------------------------华丽的分割线--------------------------- 
1. 什么是ARC
    
    Automatic Reference Counting，自动引用计数. 即ARC. 
    顾名思义:系统自动的帮助我们去计算对象的引用计数器的值,
 
    可以说是WWDC2011和iOS5引入的最大的变革和最激动人心的变化. 
    ARC是新的LLVM3.0编译器的一项特性,使用ARC,可以说一举解决了广大iOS开着所憎恨的手动管理内存的麻烦.
	
    在程序中使用ARC非常简单,只需要像往常那样编写代码. 
    只不过永远不要写retain、release、autorelease 永远要手动的调用 dealloc 这三个关键字就好,这是ARC的最基本的原则.
    当ARC开启时, 编译器会自动的在合适的地方插入retain、release、autorelase代码. 
    编译器自动为对象做引用计数. 而作为开发者,完全不需要担心编译器会做错(除非开发者自己错用了ARC).
	
    需要特别注意的是: ARC是编译器机制. 在编译器编译代码的时候,会在适时的位置加入retain、release和autorealse代码.
 
 2. ARC机制下,对象何时被释放
 
    本质: 对象的引用计数器为0的时候,自动释放.
 
    表象: 只要没有强指针指向这个对象,这个对象就会立即回收.
 
 3. 强指针与弱指针.
 
    强指针: 默认情况下,我们声明1个指针 这个指针就是1个强指针. 
           我们也可以使用__strong来显示的声明这是1个强指针.
            
           Person *p1; 这是1个强指针. 指针默认情况下都是1个强指针.
           __strong Person *p2; 这也是1个强指针.使用__strong来显示的声明强指针.
 
    弱指针: 使用__weak标识的指针就叫做弱指针.
 
           
    无论是强指针还是弱指针,都是指针,都可以用来存储地址,这1点没有任何区别 。
    都可以通过这个指针访问对象的成员.
    唯一的区别就是在ARC模式下.他们用来作为回收对象的基准. 
    
    如果1个对象没有任何强类型的指针指向这个对象的时候,对象就会被立即自动释放
 
 4. 确认程序是否开启ARC机制.
 
    1).默认情况下,Xcode开启ARC机制.
    2).ARC机制下,不允许调用retain、relase、retainCount、autorelease方法.
    3).在dealloc中 不允许[super dealloc];
 
 
 5.  演示第1个ARC案例
     int main(int argc, const char * argv[])
        {
            @autoreleasepool
            {
                Person *p1 = [Person new];//p1是1个强指针.
                //因为我们说过,每1个指针变量默认情况下都是1个强指针变量.
                NSLog(@"------");
            }//当执行到这里的时候.p1指针被回收,那么Person对象就没有任何
            //强指针指向它了. 对象就在这被回收.
            return 0;
     }

----------------------------------华丽的分割线--------------------------- 
1. ARC下的单个对象的内存管理.
 
    在ARC的机制下: 当1个对象没有任何的强指针指向它的时候 这个对象就会被立即回收.
 
 
     1). 当指向对象的所有的强指针被回收的时候,对象就会被立即回收.
 
 
     int main(int argc, const char * argv[])
     {
         @autoreleasepool
         {
            Person *p1 = [Person new];//p1是1个强指针.
            Person *p2 = p1;//p2也是个强指针.p1和p2都指向Person对象.
            //因为我们说过,每1个指针变量默认情况下都是1个强指针变量.
            NSLog(@"------");
         }//当执行到这里的时候.p1指针被回收,p2指针也被回收.那么Person对象就没有任何
         //强指针指向它了. 对象就在这被回收.
         return 0;
     }
 
     2).将所有指向对象的强指针赋值为nil的时候.对象就会被立即回收.
     
     int main(int argc, const char * argv[])
     {
         @autoreleasepool
         {
             Person *p1 = [Person new];//p1是1个强指针.
             //因为我们说过,每1个指针变量默认情况下都是1个强指针变量.
             
             p1 = nil;//当执行到这句话的时候.p1赋值为nil.
             //p1指针不再执行Person对象.
             //Person对象没有被任何的指针所指向,所以.Person对象在这里被释放.
             NSLog(@"------");
         }
         return 0;
     }
 
 
     这两种情况就叫做没有任何强指针指向对象.
     1). 指向对象的所有强指针被回收掉
     2). 指向对象的所有的强指针赋值为nil
 
 2. 强指针与弱指针.
     
    1). 强指针与弱指针的声明.
    
     默认情况下,所有的指针都是强类型的,也就是说我们之前声明的指针变量都是强类类型的
 
     p1指针是强类型的,因为默认情况下指针都是强类型的.
     Person *p1 = [[Person alloc] init];
 
     不过我们可以使用__strong来显示的标识指针是强类型指针.
     __strong Person *p2 = [Person new];
     这个时候p2指针类型是强指针类型的.其实写不写__strong都是强类型的指针.
         
     指针类型也可以是弱指针类型.
     使用__weak标识指针的类型是弱类型指针.
     __weak Person *p3 = p2;
     这个时候,p3指针就是1个弱类型的指针. p3弱指针也指向p2指针指向的对象.
 
    在操作对象的时候,通过强指针或者弱指针都可以操作,没有任何区别.
 
 
    2). ARC模式下的对象回收标准
 
     ARC机制下释放1个对象的标准是: 没有任何强指针指向对象的时候,对象就会被释放.
     如果这个时候有弱指针指向,也会被释放.
     int main(int argc, const char * argv[])
     {
         @autoreleasepool
         {
             //使用__strong来标识p1指针是强类型的,其实不写__strong也是强类型的.
             __strong Person *p1 = [[Person alloc] init];
             
             //使用__weak标识指针p2的类型是弱类型指针.
             __weak Person *p2 = p1;
             //这个时候,p2指针和p1指针都指向Person对象.
             
             //这个时候如果设置p1的值为nil
             p1 = nil;
             //这个时候Person对象只有被1个弱指针p2指向,没有任何强指针指向
             //所以Person对象在这里被回收.
         }
         return 0;
     }
 
 
     3).最重要的1点:不能创建对象用1个弱指针存储这个对象的指针.
     这样的话,刚创建出来的对象,就没有任何强指针指向,创建出来就会被回收.
     int main(int argc, const char * argv[])
     {
         @autoreleasepool
         {
             //创建1个对象,将这个对象的地址赋值给1个弱指针
             //后果就是创建出来的这个对象没有被任何强指针指向.
             //刚创建出来就会被释放.
             __weak Person *p1 = [[Person alloc] init];
             
         }
         return 0;
     }
 
 
     4). 在ARC机制下. 当对象被回收的时候. 原来指向这个对象的弱指针会被自动设置为nil

----------------------------------华丽的分割线--------------------------- 
 1. ARC机制下的对象的回收的标准: 当没有任何强类型的指针指向对象的时候,这个对象就会被立即回收.
 
  2. 强类型指针 弱类型指针.
 
  3. 什么情况下叫做对象没有强指针向指向.
 
     1).  指向对象的强指针被回收.
 
     2).  指向对象的强指针被赋值为nil
 
  4. 在ARC的机制下,@property参数不能使用retain
     因为retain代表生成的setter方法是MRC的标准的内存管理代码.
     而我们在ARC的机制下 不需要这些代码.
 
     所以,在ARC机制下的setter方法 什么都不需要做.直接赋值就可以了.
 
 
  5. ARC机制下,我们关注的重点.
     当1个类的属性是1个OC对象的时候.这个属性应该声明为强类型的还是弱类型的.
     很明显,应该声明为1个强类型的.
 
     问题来了?
 
     如何控制@property生成的私有属性,是1个强类型的还是1个弱类型的呢?
 
     使用参数, strong和weak
 
     @property(nonatomic,strong)Car *car;
     代表生成的私有属性_car 是1个强类型的.
 
     @property(nonatomic,weak)Car *car;
     代表生成的私有属性_car 是1个弱类型的.
 
 
     如果不写,默认是strong.
 
 
  6. 使用建议.
 
     1). 在ARC机制下.如果属性的类型是OC对象类型的.绝大多数场景下使用strong
     2). 在ARC机制下.如果属性的类型不是OC对象类型的.使用assign
 
     3).  strong和weak都是应用在属性的类型是OC对象的时候. 属性的类型不是OC对象的时候就使用assign.
 
 
 
     --------
     在ARC机制下,将MRC下的retain换位strong
 
     @property(nonatomic,strong)Car *car;
     做的事情:
     1).  生成私有属性.并且这个私有属性是strong
     2).  生成getter setter方法的声明
     3).  生成getter setter方法的声明
 
          setter的实现:直接赋值.

----------------------------------华丽的分割线--------------------------- 
 在ARC机制下.当两个对象相互引用的时候.如果两边都使用strong 那么就会先内存泄露.
    
 解决方案: 1端使用strong 1端使用weak

----------------------------------华丽的分割线--------------------------- 
 1. 开发程序分为ARC和MRC
 
  2. 与多线程相关的参数.
     atomic : 默认值 安全,但是效率低下.
     nonatomic: 不安全,但是效率高.
 
     无论在ARC还是在MRC都可以使用.
     使用建议: 无论是ARC还是MRC 都使用nonatomic
 
  3. retain: 
 
     只能用在MRC的模式下.代表生成的setter方法是标准的内存管理代码.
     当属性的类型是OC对象的时候.绝大多数情况下使用retain. 只有在出现了循环引用的时候1边retain 1边assign

 
  4. assign:
     在ARC和MRC的模式下都可以使用assign.
     当属性的类型是非OC对象的时候 使用assign.
 
 
  5. strong:
     只能使用在ARC机制下. 当属性的类型是OC对象类型的时候,绝大多数情况下使用strong]  
     只有出现了循环引用的时候, 1端strong 1端weak
 

  6. weak:
 
     只能使用在ARC机制下. 当属性的类型是OC对象的时候. 只有出现了循环引用的时候, 1端strong 1端weak
 
  7. readonly readwrite 
 
     无论是ARC还是MRC 都可以使用.
 
  8. setter getter 无论在ARC下还是在MRC下都可以改.
 
 
 -----------------------------
 在ARC机制下.原来使用retain的用strong
 出现循环引用的时候. MRC: 1边retain 1边assign  ARC: 1边strong 1边weak

----------------------------------华丽的分割线--------------------------- 
 1. 有可能会遇到的问题.
 
 
      程序使用的是ARC机制开发的,但是其中的某些类使用的是MRC.
 
      
 
   2. 使用命令.  -fno-objc-arc

----------------------------------华丽的分割线--------------------------- 
 1. 可以将整个MRC程序,转换为ARC程序;
 
   2. Edit-->Convert-->To Object-C ARC

----------------------------------华丽的分割线--------------------------- 
 1. 分类.
     类别、类目、category
 
 
  2. 写1个学生类:类中有很多个方法.
 
     吃 喝 拉 撒 睡.... 基本行为
     学习、敲代码、写书.... 学习
     玩Dota 玩LOL 玩CF.... 玩
     爬山、跑步、踢足球..... 运动
     ......
 
     如果将这些方法都写在同1个类模块中.当然完全是可以的.
     如果全都写在一个模块中,就显的很臃肿. 后期难以维护和管理.
 
 
     默认情况下1个类独占1个模块.这个是将所有的成员都写在这1个模块中.就很男管理.
 
     我们的想法: 那就让1个类占多个模块.将功能相似的方法定义在同1个模块中.
               这样的好处: 方便维护和管理.
 
 
     如何将1个类分成多个模块呢?
 
 
  3. 分类:
 
     1). 顾名思义: 将1个类分为多个模块.
 
     2). 如何为1个类添加分类.
 
         
     3). 会生成1个.h 和1个.m的模块.
 
         a. 模块的文件名:  本类名+分类名.h     本类名+分类名.m
 
    
     4). 添加的分类也分为声明和实现.
 
         @interface 本类名 (分类名)
 
         @end
 
         代表不是新创建1个类.而是对已有的类添加1个分类. 小括弧中写上这个分类的名字.
         因为1个类可以添加多个分类 为了区分每1个分类.所以分类要取名字.
 
 
         @implementation Student (itcast)
         
         @end
 
         这是分类的实现.
 
 
  4. 分类的使用.
 
     1) 如果要访问分类中定义的成员,就要把分类的头文件引进来.
 
 
 
  5. 分类的作用: 将1个类分为多个模块.
 
 
 
----------------------------------华丽的分割线--------------------------- 
 使用分类注意的几个地方:
    1. 分类只能增加方法,不能增加属性
 
	2. 在分类之中可以写@property 但是不会自动生成私有属性. 也不会自动生成getter setter的实现.
       只会生成getter setter的声明.
       所以,你就需要自己写getter 和 setter的声明. 也需要自己定义属性 这个属性就必须在本类中.
 
	3. 在分类的方法实现中不可以直接访问本类的真私有属性(定义在本类的@implementation之中)
       但是可以调用本类的getter setter来访问属性.
 
       本类的@property生成的私有属性,只可以在本类的实现中访问.
       分类中不能直接访问私有属性 真.
       分类可以使用 getter setter 来访问.
 
 
    4. 分类中可以存在和本类同名方法的.
       当分类中有和本类中同名的方法的时候,优先调用分类的方法.哪怕没有引入分类的头文件.
       如果多个分类中有相同的方法,优先调用最后编译的分类.
 
 
----------------------------------华丽的分割线--------------------------- 
 什么时候需要使用分类.
 
 当1个类的方法很多很杂的时候. 当1个类很臃肿的时候.
 那么这个时候我们就可以使用分类. 将这个类分为多个模块.将功能相似的方法写在同1个模块之中.

 xiahuaxian
 GC与ARC.
----------------------------------华丽的分割线--------------------------- 
 1. 本类中的真私有属性在分类中无法直接访问.
 
  2. 

----------------------------------华丽的分割线--------------------------- 
  1. 分类的作用在于可以将我们写类分为多个模块.
 
     可以不可以为系统的类写1个分类呢?
 
     为系统自带的类写分类 这个就叫做非正式协议.
 
 
  2. 分类的第2个作用:
      为1个已经存在的类添加方法.
 
 
  3. NSString类都挺好的. 就是差了1个方法.
 
     统计字符串对象中有多少个阿拉伯数字.
 
 
 
 
 
  分类的作用
 
  1). 将臃肿的类分为多个模块 方便管理.
 
  2). 扩展1个类.

----------------------------------华丽的分割线--------------------------- 
 1. ARC机制垃圾回收机制的区别.
 
     GC: 程序在运行的期间,有1个东西叫做垃圾回收器.不断的扫描堆中的对象是否无人使用.
 
         Person *p1 = [Person new];
         p1 = nil;
 
 
     ARC: 不是运行时. 在编译的时候就在合适的地方插入retain......
          插入的代码足以让对象无人使用的时候 引用计数器为0
 
 
 
 
  2. 

----------------------------------华丽的分割线--------------------------- 
 1. 复习
  2. 延展
  3. block
  4. 协议.
 
 ---------------
 1.自动释放池.
   1). MRC下才具备作用.
   2). 原理:
   3). 如何创建1个自动释放池
       @autoreleasepool
       {
 
       }
 
   4). 调用对象的autorelease方法的代码放在自动释放池.
 
 
   5). 好处:
       在MRC下.创建对象把对象存储到自动释放池中 省略1个release.

  2. ARC 自动内存管理. 系统自动的计算对象的引用计数器的值.
     编译器特性
 
     没有任何强指针指向1个对象的时候 这个对象就会被立即回收.
 
 
  3. @property参数
     strong weak
 
     当1个类的属性是1个OC对象的时候.在ARC模式下 这个属性应该要是1个强类型的还是1个弱类型的.
     绝大多数情况下 应该要是1个强类型.
 
    
     strong与weak 都是应用在属性的类型是OC对象的时候.
     99.99% strong
     当出现循环引用的时候. strong weak
 
 
  4. 总结@property参数.
 
 
  5. MRC与ARC的兼容.
 
 
  6. MRC转换为ARC
 
 ------分类-------------
 1. 作用:
 
    1). 将1个臃肿的类分为多个模块.方便后期的代码的维护.
 
    2). 对1个类进行扩展. 使用分类为已经存在的类添加方法.
 
 
 
 2. 扩展1个类. 为1个类新增成员.;
 
    继承: 新创建了1个类.
         继承的扩展 可以扩展任意成员.
 
    分类: 没有新创建1个类.看起来就像修改的是本类一样.
         分类只能加方法.

----------------------------------华丽的分割线--------------------------- 
 1. 延展: Extension
     1). 是1个特殊的分类. 所以延展也是类的一部分.
     2). 特殊之处:
         a. 延展这个特殊的分类没有名字.
         b. 只有声明没有实现.和本类共享1个实现.
 
 
  2.延展的语法
 
    语法;
    @interface 本类名 ()

    @end
 
    没有实现. 和本类共享1个实现.
 
 
  3.为类添加延展的步骤
 
    只有1个.h文件. 文件名称: 本类名_取得文件名.h
 
    这个文件中只有延展的声明.
 
    @interface Person ()
 
    @end
 
 
  4. 延展的基本使用.
 
    1). 延展的本质是1个分类. 作为本类的一部分.
        只不过是1个特殊的分类
        没有名字.
 
    2). 延展只有声明,没有单独的实现. 和本类共享一个实现.
 
 
  5. 延展和分类的区别
 
    1). 分类有名字.延展没有名字 是1个匿名的分类.
    2). 每1个分类都有单独的声明和实现. 而延展只有声明 没有单独的实现 和本类共享1个实现,
    3). 分类中只能新增方法. 而延展中任意的成员都可以写.
    4). 分类中可以写@property 但是只会生成getter setter的声明.
        延展中写@property 会自动生成私有属性 也会生成getter setter的声明和实现.
 
 
 
  6. 延展的应用场景.
 
 
     1). 要为类写1个私有的@property.
 
         生成getter、setter方法只能在类的内部访问 不能在外部访问.
         其实,我们可以想: @property生成私有属性、生成getter setter的实现,不要声明.
 
 
     2). 延展100%的情况下不会独占1个文件. 都是将延展直接写在本类的实现文件中.
         这个时候,写在延展中的成员,就相当于是这个类的私有成员.只能在本类的实现中访问.
         外部不能访问.
 
 
     3). 什么时候使用延展?
         当我们想要为类定义私有成员的时候,就可以使用延展. 将延展定义在这个类的实现文件中.
 
         如果想要为类写1个真私有属性,虽然我们可以定义在@implementation之中.但是不要这么写 这样很不规范.  
         写1个延展.将这个私有属性定义在延展中.
 
         如果要为类写1个私有方法,建议将声明写在延展中, 实现写在本类的实现中. 提供代码的阅读性
 
         如果想要为类写1个私有的@property 就直接写在延展就可以了.
 
 
     4). 延展天生就是来私有化类的成员的.
         如果类的成员只希望在类的内部访问,那么就将其定义在延展中.
         如果类的成员允许被外界访问 定义在本类的@interface中.

----------------------------------华丽的分割线--------------------------- 
1. OC在C的基础之上新增了一些数据类型.
 
     BOOL
     Boolean
     class
     nil
     SEL
     id
     block
 
 
  2. block是1个数据类型.
     int double float char .......
     既然是1个数据类型,那么就可以声明这个数据类型的变量. 所以我们完全也可以声明1个block类型的变量.
     不同类型的变量中可以存储不同类型的数据.
     那么block类型的变量中可以存储什么样的数据呢?
 
     1). block是1个数据类型 所以我们可以声明1个block类型的变量.
 
     2). block类型的变量中专门存储1段代码. 这段代码可以有参数 可以有返回值.
 
 
  3. block变量的声明
     
 
     1). 虽然block变量中是用来存储1段代码的.但是1个block变量中并不是任意的1段代码都可以存进去的
         而是有限定的.
 
         也就是说.在声明block变量的时候.必须要指定这个block变量存储的代码段是否有参数.是否有返回值.
         一旦指定以后,这个block变量中就只能存储这样的代码了.
 
         声明了1个block变量.返回值是void 参数是1个int类型的.
         这个时候. 这个block变量中就只能存储无返回值并且有1个int参数的代码段.
 
 
     2). 声明block变量的语法格式:
         
         返回值类型 (^block变量的名称)(参数列表);
 
         void (^myBlock1)(); 表示声明了1个block类型的变量叫做myBlock1 这个变量中只能存储没有返回值没有参数的代码段.
 
         int (^myBlock2)(); 
 
         int (^myBlock3)(int num1,int num2);
 
     3). 最重要的
         声明block变量的时候要指定这个block变量可以存储的代码段的返回值和参数描述.
         一旦指定.这个block变量中就只能存储这样的代码段了. 其他格式的代码段无法存储.
 
 
  4. 初始化block变量
     1). 原理: 写1个符合block要求的代码段.存储到block变量中就可以了.
 
    
     2). 代码段的书写格式:
 
         ^返回值类型(参数列表){
            代码段;
         };
 
     3). 写1个无参数无返回值的代码段.
 
         ^void(){
            NSLog(@"我爱你");
            NSLog(@"我恨你");
         };
 
         这个时候,我们就可以将这段代码使用赋值符号存储到 无返回值无参数要求的block变量中.
         void (^myBlock1)();
         myBlock1 =  ^void(){
             NSLog(@"我爱你");
             NSLog(@"我恨你");
         };
         当然也可以在声明block变量的同时使用符合要求的代码段初始化.
    
         void (^myBlock1)() =  ^void(){
             NSLog(@"我爱你");
             NSLog(@"我恨你");
         };
         
     4). 有返回值的代码段.
    
         ^int(){
            int num1 = 10 + 20;
            return num1;
         };
        
         我们就可以将这段代码赋值给符合要求的block变量.
         int (^myBlock2)() =  ^int(){
             int num1 = 10 + 20;
             return num1;
         };
 
 
     5). 既有参数既有返回值的代码段.
 
         ^int(int num1,int num2){
            int num3= num1 + num2;
            return num3;
         };
        
         所以 我们可以将这个代码赋值给符合要求的block变量.
 
         int (^myBlock3)(int num1,int num2) =  ^int(int num1,int num2){
             int num3= num1 + num2;
             return num3;
         };
 
 
 
     6). 注意.
 
         赋值给block变量的代码段必须要符合block变量的要求. 否则就会报错.
 
 
  5. 如何执行存储在block变量中的代码段.
 
 
     语法格式: block变量名();
     
     有参数就传参数.有返回值就接.
 
 
  6. 关于block的简写.
 
     1). 如果我们写的代码段没有返回值.那么代码段的void可以省略.
         void (^myBlock1)() =  ^(){
             NSLog(@"我爱你");
             NSLog(@"我恨你");
         };
         注意,我说的是代码段的返回值如果是void可以省略,声明block变量的返回值无论是什么不可以省略.
         
 
     2). 如果我们写的代码段没有参数,那么代码段的小括弧写可以省略.
 
         int (^myBlock2)() =  ^int{
             int num1 = 10 + 20;
             return num1;
         };
         再次强调: 我们说的是代码段.
 
         所以,当1个代码段既没有参数,也没有返回值的适合,就只写^
 
         void (^myBlock1)() =  ^{
             NSLog(@"我爱你");
             NSLog(@"我恨你");
         };
         
 
     3).声明block变量的时候.如果有指定参数.可以只写参数的类型而不写参数的名称;
 
     int (^myBlock3)(int,int) =  ^int(int num1,int num2){
         int num3= num1 + num2;
         return num3;
     };
     注意: 这个地方我们说的是声明block变量的时候 再写代码段的时候 类型和名称都要写.
 
 
     4).无论代码段是否有返回值.在写代码的时候.可以不写返回值类型 省略.
        如果在写代码段的时候,省略了返回值,这个时候系统会自动的确定返回值的类型.
 
        如果代码段中没有返回任何数据 那么它会认为这个代码段是没有返回值的.
        如果代码中有返回数据 返回的数据是什么类型 它就会认为这个代码段是什么类型的.
 
 
    建议: 仍然按照我们最标准的写法来写block变量和block代码段.因为这样可以提高代码的阅读性.
 
 
 
  7. 简化block变量的复杂定义.
 
     1). 问题: 定义block变量的时候.要写好大1串啊! 类型好长.
 
     2). typedef的使用场景: 将1个长类型定义为1个短类型.
 
     3). 我们也可以使用typedef将长的block类型 定义为1个短类型.
 
         typedef 返回值类型 (^新类型)(参数列表);
    
         typedef void (^NewType)(); 代表重新定义了1个类型叫做NewType 是1个block类型 无参数无返回值的block类型
 
 
  8. 关于block块访问外部变量的问题.
 
 
     1). 在block代码块的内部可以取定义在外部的变量的值, 定义在外部的局部变量和全局变量.
 
     2). 在block代码块的内部可以修改全局变量的值.但是不能修改定义在外部的局部变量的值.
 
     3). 如果你希望我们定义的局部变量可以允许在block代码的内部去修改,那么就为这个局部变量加1个__block的修饰符.
 
 -------总结-------
 1.  block是1个数据类型.
 2.  block变量是来存储1段代码的.
 3.  block变量的声明.
 4.  block变量的初始化
 5.  执行存储在block变量中的代码.
 6.  关于4个简写.
 7.  使用typedef将复杂的block定义简化.
 8.  访问外部变量的问题.

----------------------------------华丽的分割线--------------------------- 
1. block是1个数据类型.能不能不能作为函数的参数呢? 当然是可以的.
 
 
   2. 如何为函数定义block类型的参数?
      a. 就是在小括弧中声明1个指定格式的block变量就可以了.
      b. 可以使用typedef简化定义,这样看起来就不会晕了.
 
 
   3. 如何调用带block参数的函数呢?
 
      a. 如果要调用的函数的参数是block类型的,那么要求在调用的时候传入1个和形参block要求的代码段.
 
      b. 调用的时候,可以先讲代码段存储到1个block变量中,然后再传递这个block变量
         也可以直接将符合要求的代码段写在小括弧中传递.
 
      c. 小技巧. 通过Xcode提示可以快速的生产block代码段的框架.
 
 
   4. 将block作为函数的参数可以实现什么样的效果?
 
      可以将调用者自己写的1段代码 传递到 函数的内部去执行.
 

.
 
   5. block也可以作为函数的返回值.
 
      当将block作为函数的返回值的时候,返回值的类型就必须要使用typedef定义的短类型.
 

  
   6. block与函数
 
      相同点: 都是封装1段代码.
 
      不同点:
      1). block是1个数据类型.函数是1个函数.
      2). 我们可以声明block类型的变量  函数就只是函数. 
      3). block可以作为函数的参数. 而函数不能直接作为函数的参数.

----------------------------------华丽的分割线--------------------------- 
写1个类. 数组类.  给这个数组类提供1个方法 将1个国家字符串数组进行排序.
 
 
   什么时候block可以作为方法、函数的参数?
 
    当方法的内部需要执行1个功能.但是这个功能具体的实现函数的内部不确定.
    那么这个时候,就使用block让调用者将这功能的具体实现传递进来.

----------------------------------华丽的分割线--------------------------- 
 1. 协议:protocol.

 
    作用: 
    1). 专门用来声明一大堆方法. (不能声明属性,也不能实现方法,只能用来写方法的声明).
    2). 只要某个类遵守了这个协议.就相当于拥有这个协议中的所有的方法声明.而不用自己去定义.

 
 
    
  2. 协议的声明.
 
     @protocol 协议名称 <NSObject>

     方法的声明;
 
     @end
 
 
     新建1个协议的方式.  NewFile OC-File - protocol
     协议的文件名: .h 并且只有1个.h文件.
 
 
     在协议中,只能用来声明方法,协议的作用:就是专门用来写方法声明的.
 
    
 
 
  3. 类遵守协议.
 
 
     协议就是用来写方法声明的,就是用来被类遵守的.
 
     如果想要让1个类,拥有协议中定义的所有的方法声明.那么就让这个类遵守这个协议.
     类只要遵守1个协议,那么这个类就拥有了这些协议中定义的所有的方法的声明了.
 
 
     @interface 类名 : 父类名 <协议名称>
 
     @end
 
     : 表示继承.
     <> 表示遵守的协议.
 
     当1个类,遵守了1个协议,那么就相当于这个类拥有了协议中定义的所有的方法的声明.
     这个类只是拥有了这个协议中的方法的声明而已. 没有实现.所以 这个类,就应该实现协议中的方法.
 
 
     如果类不实现协议中的方法,其实也不会报错.编译器只是会报警告.
     但是当创建对象,来调用这个没有实现的协议中的方法的时候,就会报错.
 
 
 
 
  4. 类是单继承. 但是协议可以多遵守.
 
     1个类只能有1个父类
     但是1个类可以同时遵守多个个协议.
 
     @interface 类名 : 父类名  <协议名称1,协议名称2......>
 
     @end
 
     当1个类遵守了多个协议之后,就相当于这个类拥有了所有协议中定义的方法的声明.
     那么这个类,就应该实现所有协议中的方法.
        
     如果不实现,其实也不会报错.编译器只是会报警告.
     但是当创建对象,来调用这个没有实现的协议中的方法的时候,就会报错.
 
    --------
     当1个类遵守了某个协议.就相当于这个类拥有了这份协议中的所有的方法的声明.
     但是仅仅只是有方法的声明而已,没有是实现,要类自己去实现.
 
     如果类不实现.编译器不会报错. 只是给1个警告.
     当我们创建对象,如果不调用这个协议方法,就不会报错.
     如果要调用这个协议方法,那就会报错.
 
 
 
 
 
 
  5. @required 与 @optional
 
     当1个类遵守了1份协议.这个类就拥有这个协议中的所有的方法声明 仅仅是只有声明而已.还要自己实现.
     如果不实现呢?也不会报错 只是给1个警告.
 
 
     @required 与 @optional这两个修饰符是专门用来修饰协议中的方法的.
 
     在协议中,如果方法的声明被@required修饰,那么遵守这个协议的类必须要实现这个方法,否则编译器会发出警告.
     在协议中,如果方法的声明被@optional修饰,那么遵守这个协议的类如果不实现这个方法.编译器也不会报警告.
 
     其实,无论是@required还是@optional你都可以不实现. 编译器是不会报错的. 仍然可以编译 运行.
     唯一的区别就是: 当遵守协议的类不实现协议中的方法的时候,@required会给1个警告. @optional警告都木有.
 
 
 
     
     这两个关键字的主要作用:在于程序员沟通,告诉遵守协议的类 哪些方法是必须要实现的,
 
 因为这些方法我会调用.
 
     默认的是@required
 
 

 
 
 
  6. 协议可以从另外1个协议继承,并且可以多继承.

     协议可以继承另外1个协议.  A 协议 继承了 B协议. 那么A协议中不仅有自己的方法的声明,还有B协议中的方法的声明.
     如果有1个类遵守了A协议，那么这个类就拥有了, A、B协议中的所有的方法的声明.
 
     协议之间继承的语法格式
     @protocol A协议名称 <B协议名称>
     
     @end
 
     代表A协议继承自B协议, A协议中既有自己的方法声明,也有B协议中的方法声明.
 
 
 
  
     NSOBject: 这是1个类. 是所有的OC类的基类. 这个类是苹果早就定义好得.
     NSOBject: 这也是1个协议. 也是苹果早就定义好得. 这个协议被NSObject类遵守.
               所以,所有的OC对象都拥有这个协议中的所有的方法.
               这个协议我们也叫做基协议.
 
     写协议的规范: 任何1个协议,必须要间接的或者直接的去遵守这个NSObject基协议.
 
     协议的名称可以和类的名称相同:

 
 
 7. @protocol类型限制.
     
    1). 要求某个指针保存的是遵守指定协议的对象.    
 
        NSObject<myProtocol> *obj;
 
        id<myProtocol> *obj;
 
 
    2). 要求某个指针变量保存的是继承了某个类,并遵守了指定协议的对象.
 
 
 
    3). 属性案例:  男孩子的女朋友.
 
 
    4). 为什么要求对象遵守协议?
 
        因为我要调用对象的这个方法 你只有遵守了这个协议才有这个方法.
 
    5). 协议与继承,
 
        超人 鸟  飞机 装X飞.
        
 
 
 
 8.案例: 婴儿饿了要哭 困了要睡 保姆开照顾. 老师也能当保姆.

----------------------------------华丽的分割线--------------------------- 
 1. 协议与协议之间可以相互继承.
 
     1). 继承的语法:
          
         @protocol 协议名称 <父协议名称>
 
         @end
 
     2). 效果:
         子协议中不仅有自己的方法的声明,还有父协议中的所有的方法的声明.
         如果1个类遵守了某份协议,那么这个类就拥有这个协议和这个协议的父协议中的所有的方法声明.
 
 
  2. 介绍1个东西. NSObject
     
     在Foundation框架中,有1个类 叫做NSObject 是所有OC类的基类.
     在Foundation框架中,有1个协议.叫做NSObject.
 
     NSObject协议被NSObject类遵守.所以,NSObject协议中的所有的方法 全部的OC类都拥有了.
     这么说,所有的OC类都遵守了NSObject协议. NSObject协议叫做基协议.
 
     类的名称可以和协议的名称一致.
 
 
  3. 写协议的规范:
     
     要求所有的协议都必须直接的或者间接的从NSObject基协议继承.

----------------------------------华丽的分割线--------------------------- 
 1. 请声明1个指针.这个指针可以指向任意的对象,但是要求指向的对象要遵守指定的协议.
      如果不遵守 最起码要报1个警告.
 
      要求声明1个指针 指向1个遵守了学习协议的对象, 否则最起码要给哥哥1个警告.
 
      NSObject<协议名称> *指针名;
      这个时候,这个指针可以指向遵守了指定协议的任意对象. 否则就会报1个警告.
      NSObject<StudyProtocol> *obj = [Student new];
 
 
      当然了完全也可以使用id指针.
      id<协议名称> 指针名;
      id<StudyProtocol> id1 =  [Student new];
 
 
   2. 声明1个指针变量,要求这个指针变量指向的对象必须遵守多个协议.

      NSObject<StudyProtocol,SBProtocol> *obj1 = [Student new];
 
      id<StudyProtocol,SBProtocol> obj1 = [Student new];
 
 
   3. 定义1个指针,指向遵守了学习协议的学生对象.
 
 
   4. WHY?
 
      1). 遵守了某个协议的类,就相当于这个类拥有了这个协议所定义的行为.
 
      2). 因为我要调用这个对象中的协议方法.
          只有类遵守了协议,这个类中一定才会有协议方法.

----------------------------------华丽的分割线--------------------------- 
男孩子找女朋友.
 
 
    要求:
     必须
     1). 会洗衣服
     2). 会做饭
     优先:
     如果有份过万的月薪的工作.
 
 
 
 
  男孩子类:
     属性:姓名,年龄,钱,女朋友.
     行为:谈恋爱.
 
 
  定义1个协议;女朋友协议.
    洗衣
    做饭

----------------------------------华丽的分割线--------------------------- 
 0. 注意
      我们暂时只是将实现的简单的语法. 应用.
 
 
  1. 什么是代理模式.
 
     传入的对象,代替当前类完成了某个功能,称为代理模式.
 
  2. 利用协议实现代理模式的主要思路.
 
     1). 定义1个协议.里面声明代理类需要实现的方法列表. 比如这里的1个代理类需要实现wash cook方法.
     2). 创建1个代理类(比如猪猪) 遵守上面的代理协议 并实现方法
     3). 在需要代理的类中,定义1个对象属性 类型为id 且遵守代理协议的属性.
     4). 在代理的类中,调用代理对象的方法.
 
 
    代理模式:
      有1个对象中有1个属性, 这个属性的可以是任意的对象,但是这个对象必须具有指定的行为.
       这个时候就可以使用协议.
 
      将行为定义在代理之中.
      对象的属性的类型 id<协议>
      只要遵守了这个协议的对象都可以作为这个类的代理.
 
  3. 代理设计模式的场合
     1). 当对象A发生了一些事情,想告知对象B 让对象B称为对象A的代理.
     2). 对象B想监听对象A的一些行为. 让B称为A的代理,
     3). 当对象A无法处理某些场景的时候,想让对象B帮忙处理.
 
 
 
  5. 婴儿饿了就会哭 哭的时候要有1个人喂他吃奶.   
     困了就要睡.困的时候就要1个人去哄他睡觉.
 
     用代理设计模式.为婴儿找1个可以照顾它的人.
 
    
     Baby
       属性:
          姓名
          年龄.
          照顾他的人.
 
       行为:
          哭
          吃奶
          睡觉
          犯困的行为.
    
 
     可以照顾这个小孩子的人要求:
 
        喂奶 哄孩子睡觉.

----------------------------------华丽的分割线--------------------------- 
 Foundation框架. 
  NSString
  NSMutableString
  NSArray
  NSMutableArray
  NSDictionary
  NSMutableDictionary
  NSFileManger
  NSDate
  NSVlue
  NSNumber
  copy
  单例模式.
 ----------------
 1. 延展
    什么时候用以及如何使用?
 
 
 2. block
 
    1).应用场景
 
 3. 协议
    1). 
 
    2). 协议的类型限制.
 
 
    3). 简单的代理设计模式.
 
        对象的属性 任何类型的对象都可以 但是要求遵守指定的协议.
                  因为要调用对象的协议方法.
 

----------------------------------华丽的分割线--------------------------- 
1. 框架: 就是系统(苹果)或者第三方(其他的一些高手)事先写好了一些很牛X功能的类.
          把这些类交给我们使用.这些类的集合我们叫做框架.
 
          框架中有很多很多功能相似的类. 函数库
 
     Foundation框架:  是1个包 这里面有很多类、函数、定义了一些数据类型.
                      这个框架中的类都是一些最基础的类. NSString NSObject
                     其他的框架都是基于Foundation框架的.
 
     UIKit.
     AVFoundation.
     ......
 
 
  2. Foundation框架中的最常用的类. 简单的爆.量大.

    
 
  3. NSString
 
     1). NSString是1个数据类型.保存OC字符串的.
         NSString的本质是1个类.既然是1个类.
 
         所以,最标准的创建NSString对象的方式:
         NSString *str1 = [NSString new];
         NSString *str2 = [[NSString alloc] init];
         NSString *str3 = [NSString string];
 
         使用这种方式创建的字符串是1个空的字符.  @""
 
         NSString对象就是用来存储字符串.
 
 
     2). NSString是OC中最常用的1个类了.所以OC提供了一种更为快速的创建字符串对象的方式.
         使用前缀@
 
         @"jack"; 本质上这是1个NSString对象.这个NSString对象中存储的是"jack"这个字符串.
 

        NSString *str1 = @"rose";
 
        1).  @"rose"本质上是1个NSString对象,这个对象中存储的是字符串"rose".
        2).  将这个字符串对象的地址返回赋值给str1指针.
 
 
 
 
         格式控制符%p: 打印指针变量的值.打印地址.
                  %@:  打印指针指向的对象.
 
 
  4. NSString的恒定性.
 
     1). 当我们使用简要的创建字符串对象的时候.也就是使用1个OC字符串常量来初始化字符串指针的时候.
         这个字符串对象是存储在 常量区(数据段) 的.
 
         NSString *str = @"jack";
 
         当我们调用NSString的类方法来创建对象的时候.
 
         NSString *str =  [NSString stringWithFormar:@"jack"];
         NSString *str1 = [NSString new];
         创建的字符串对象是存储在堆区.
 
 
     2). 当在内存中创建1个字符串对象以后.这个字符串对象的内容就无法更改.
         当我们重新为字符串指针初始化值的时候.并不是修改原来的字符串对象 
         而是重新的创建1个字符串对象 将这个字符串对象的地址重新复制给字符串指针变量.
 
 
     3). 当系统准备要在内存中创建字符串对象的时候.会先检查内存中是否有相同内容的字符串对象.
         如果有,直接指向. 如果没有才会重新创建.
 
 
     4). 存储在常量区的数据不会被回收. 所以存储在常量区的字符串对象也不会被回收.

----------------------------------华丽的分割线--------------------------- 
 1. NSString是1个类.那么肯定其中有很多的方法.
 
 
  2. 使用频率最最高的几个方法.
 
     1). 使用拼接的方式创建1个NSString对象.
 
         + (instancetype)stringWithFormat:(NSString *)format, ... 
 
 
     2). 得到字符串的长度.
         @property (readonly) NSUInteger length;
 
     3). 得到字符串中指定下标的字符.
         - (unichar)characterAtIndex:(NSUInteger)index;
 
         返回值是unichar类型的 要打印的话使用%C
 
 
     4). 判断两个字符串的内容是否相同.
 
         a. 能否使用 == 来判断两个OC字符串的内容是否相同.
 
         b. == 运算符的作用: 比较左右两边的数据是否相同.
 
            ->   10 == 10  这个时候直接比较的是左右两边的数据是否相同.
            ->   a == b   两边也可以写1个变量.这个时候比较是左右两边的变量的值是否相同.
            ->   如果两边是1个指针变量.那么比较的也是变量的值. 只不过指针变量的值是地址.
 
 
         c. 所以,如果我们要比较两个OC字符串的内容是否相同.不能使用 == 去比较.
            因为 == 比较的是字符串指针变量的值.而我们要比的是两个字符串指针指向的字符串对象的内容是否相同.
 
         c. 调用方法: 
            - (BOOL)isEqualToString:(NSString *)aString;
            就可以比较当前字符串对象和传入的字符串对象的内容是否相同.
 
 
     5). 将C语言的字符串转换为OC字符串对象.
 
         + (instancetype)stringWithString:(NSString *)string;
 
 
     6). 将OC字符串对象转换为C语言的字符串.
 
         @property (nullable, readonly) __strong const char *UTF8String

----------------------------------华丽的分割线--------------------------- 
1. 将字符串写入到指定的文件中.
 
     - (BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFile encoding:(NSStringEncoding)enc error:(NSError **)error;
 
 
  2. 将文件中的内容读取到字符串中.
     + (nullable instancetype)stringWithContentsOfFile:(NSString *)path encoding:(NSStringEncoding)enc error:(NSError **)error;
 
     nullable 代表返回的对象有可能是nil
 
  3. 使用NSURL读写资源.
     
     1). NSURL对象. 专门用来保存资源地址的. 资源地址: 本地磁盘路径、网页地址、ftp文件地址.
 
     2). 资源路径的地址的写法:
         http://   开头的是网页路径的写法.
         file://   开头的是本地磁盘的路径
         ftp://    开头的是ftp文件资源的路径
         如果要讲1个资源路径的地址保存到NSURL对象中 地址一定要是标准写法.
 
     3). 如何将资源地址存储到NSURL对象中.
         NSURL *url1 = [NSURL URLWithString:@"http://www.itcast.cn"];
         NSURL *url2 = [NSURL URLWithString:@"ftp://server.itcast.cn/ccc.txt"];
         NSURL *url3 = [NSURL URLWithString:@"file:///Users/Apple/Desktop/abc.txt"];
 
     4). 字符串就提供了对应的方法去读写NSURL对象中封装的资源路径
 
 
         从指定资源路径读取文本内容.
         + (nullable instancetype)stringWithContentsOfURL:(NSURL *)url encoding:(NSStringEncoding)enc error:(NSError **)error;
 
         将字符串的内容写入到资源路径中.
         - (BOOL)writeToURL:(NSURL *)url atomically:(BOOL)useAuxiliaryFile encoding:(NSStringEncoding)enc error:(NSError **)error;
 
         如果要向网页或者ftp写内容要有权限.
 
 
  4. 字符串比较.
     - (NSComparisonResult)compare:(NSString *)string;
 
 
  5. 字符串比较:忽略大小写的比较:
 
 
  6. 字符串的相等判断.
 
 
         
         
  7. 判断字符串是否以指定的字符串开头
     - (BOOL)hasPrefix:(NSString *)str;
 
  8. 判断字符串是否以指定的字符串结尾
     - (BOOL)hasSuffix:(NSString *)str;
 
 
  9. 在主串中搜索子串.从前往后
 
     - (NSRange)rangeOfString:(NSString *)searchString;
 
     返回值是1个NSRange类型的结构体变量.
 
     typedef struct _NSRange {
         NSUInteger location; 代表子串在主串出现的下标.
         NSUInteger length; 代表子串在主串中匹配的长度.
     } NSRange;
 
     如果没有找到:
     location 为NSUInteger的最大值, 也就是NSNotFound
     length 的值为0
 
 
     这个方法,是从前往后搜索. 第1次匹配的子串.
 
 
  10.在主串中搜索子串.从后往前.
 
        NSString *str = @"i love itcast love!";
 
        NSRange range =  [str rangeOfString:@"love" options:NSBackwardsSearch];
 
 
 
 11. NSRange结构体.
 
     1). 是Foundation框架中定义的1个结构体.
 
         typedef struct _NSRange {
            NSUInteger location;
            NSUInteger length;
         } NSRange;
 
         NSRange range;
 
         这个结构体变量一般情况下用来表示1段范围.特别用在子串在主串中的范围表示.
 
        @"hahajackhehe" @"jack" 
 
         4  4
 
        NSRange range = {4, 4};

 
 
    2). 声明并初始化结构体变量的方式.
 
        1). 最原始的方式.
             NSRange range;
             range.location = 3;
             range.length = 4;
 
        2). 第二种方式:    NSRange range = {3, 7};
        3). 第三种方式:   NSRange range = {.location = 3,.length = 7};
 
 
        4). Foundation框架中定义了1个函数.这个函数可以快速的创建1个NSRange结构体会,
 
            NSRange range =  NSMakeRange(loc, len);
            返回1个指定属性的NSRange结构体变量.
 
 
        5). Foundation框架中定义了1个函数 可以将1个NSRange结构体变量转换为NSString
 
             NSStringFromRange(ran) 函数可以将NSRange结构体变量转换为指定格式的字符串.

----------------------------------华丽的分割线--------------------------- 
 1. 字符串的截取.
     取到字符串中的1部分.
 
 
     - (NSString *)substringFromIndex:(NSUInteger)from; 从指定的下标出一直截取到最后.
     - (NSString *)substringToIndex:(NSUInteger)to; 从第0个开始截取指定的个数.
     - (NSString *)substringWithRange:(NSRange)range; 截取指定的1段范围.
 
 
  2. 字符串的替换
 
     - (NSString *)stringByReplacingOccurrencesOfString:(NSString *)target withString:(NSString *)replacement
 
     将字符串中第1个参数替换为第2个参数.友情提示: 原来的指针指向字符串的内容是不会变的  会全部替换.
     新串是以方法的返回值返回的.
 
     这个方法还可以做删除. 原理: 将其替换为@""
 
 
  3. 字符串数据转换为其他的类型. 使用频率很高.
 
     @property (readonly) double doubleValue;
     @property (readonly) float floatValue;
     @property (readonly) int intValue;
     @property (readonly) NSInteger integerValue
     @property (readonly) long long longLongValue
     @property (readonly) BOOL boolValue
 
 
     转换注意. 从头开始转换,能转换多少就是多少. 到遇到不能转换的时候就停止转换.
 
 
  4. 去掉字符串前后的空格.
     str =  [str stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
     中间的空格无法去掉.

----------------------------------华丽的分割线--------------------------- 
 1. 字符串的恒定性.
     一旦创建1个字符串对象,那么这个字符串对象的内容就无法更改, 当我们修改字符串的时候,其实是重新的创建了1个字符串对象.
 
     代码案例:
     NSLog(@"-------------------");
     NSString *str = @""; //@""
     for(int i = 0; i < 50000; i++)
     {
        str = [NSString stringWithFormat:@"%@%d",str,i];
     }
     NSLog(@"-------------------");
     会耗费很长的时间. 每次循环的时候 都会创建1个新的字符串对象.50000个,
     因为字符串的恒定性.
 
 
 2. 如何让这样的大批量的字符串拼接可以更加快速的1点.
 
    1). 慢得原因: 因为字符串的恒定性,每次修改字符串的时候,是重新的创建1个对象,
 
    2). 希望: 有没有一种对象是用来存储字符串的,并且存储在这个对象中的字符串数据可以更改.
 
 
 3. NSMutableString
 
    1). 是Foundation框架中的1个类.从NSString继承.
        所以,NSMutableString对象是用来存储字符串数据的.
 
    
    2). NSMutbaleString在父类NSString的基础之上的做扩展.
 
        存储在NSSMutableString对象中的字符串数据可以更改.具备可变性.
        直接可以改存储在NSMutableStirng对象中的字符串数据,不会新创建对象.
 
 
 4. NSMutableString的用法
   
    1). 既然是1个类,要使用的话,就得创建1个对象.
 
 
        NSMutableString *str = [NSMutableString string];
 
 
    2). 往可变字符串对象中追加字符串.
 
         - (void)appendString:(NSString *)aString;  直接追加内容.
         - (void)appendFormat:(NSString *)format, ... 以拼接的方式往可变字符串对象中追加内容.
 
 
    3). 创建NSMutableString对象的时候,记住下面这样的初始化方式是不行的.
         
        NSMutableString *str = @"jack";
 
        @"jack" 是1个NSString对象,是1个父类对象.
        而str指针是1个NSMutableString类型的 是1个子类类型的.       
        如果通过子类指针去调用子类独有的成员 就会运行错误.
 
 
    4). NSMutableString从NSString继承.
        在使用NSString的地方完全可以使用NSMutableString
 
 
 
  5. 使用NSMutableString来做大批量的字符串拼接.
 
     NSLog(@"~~~~~~~~~~~~");
     NSMutableString *str = [NSMutableString string];
     for(int i = 0; i < 100000; i++)
     {
        [str appendFormat:@"%d",i];
     }
     NSLog(@"~~~~~~~~~~~~");
 
    这个时候 "biu"的一下就结束了. 为什么这么快>? 因为NSMutableString只有1个.每次修改的时候 直接修改的是这个对象中的数据.
     
 
 6. 使用建议
     
    1). 我们平时使用的时候,还是使用NSString. 因为效率高.
        NSString *str1 = @"jack";
        NSString *str2 = @"jack";
 
 
    2). NSMutbaleString: 只在做大批量的字符串拼接的时候才使用.
        大量拼接的时候,就不要去使用NSString 因为效率低下.\
 
        10次以上.

----------------------------------华丽的分割线--------------------------- 
 1. 回忆C语言中的数组
     特点:
     a. 存储多个数据.
     b. 类型相同.
     c. 长度固定.
     d. 每1个元素都是紧密相连的.
 
  2. NSArray
     1). 是Foundation框架中的一个类.这个类的对象是来存储多个数据的,具备数组的功能.
         所以,NSArray是OC中的数组.
 
     2). 特点:
         a. 只能存储OC对象.任意的OC对象 无法存储
         b. 长度固定. 一旦NSArray数组创建完毕之后,元素的长度固定,无法新增 无法删除元素.
         c. 每1个元素都是紧密相连的. 每1个元素仍然有自己的下标.
         d. 元素的类型是id类型的.
 
 
  3. NSArray数组的创建.
 
     1). 因为这是1个类,所以当然就是创建NSArray对象.
 
         NSArray *arr1 = [NSArray new];
         NSArray *arr2 = [[NSArray alloc] init];
         NSArray *arr3 = [NSArray array];
 
         这样创建出来的NSArray数组的元素的个数是0个,因为长度固定.所以没有任何意义.
 
 
     2). 创建数组的同时指定1个数组的元素
 
         + (instancetype)arrayWithObject:(ObjectType)anObject;

         NSArray *arr = [NSArray arrayWithObject:@"jack"];
         仍然没有意义,因为这个数组中只有1个元素.
 
 
     3). 最常用的创建NSArray数组的方式.
 
         + (instancetype)arrayWithObjects:(ObjectType)firstObj, ...
 
         NSArray *arr = [NSArray arrayWithObjects:@"jack",@"rose",@"lili",@"hanmeimei",nil];
 
         使用注意
         1). 只能存储OC对象.不能存储非OC对象.
         2). 将元素写完以后,最后要写1个nil 表示元素到此结束了.
        
 
     4). 创建NSArray数组的简要方式.
 
         NSArray *arr = @[写上每1个元素的值用逗号分隔.];
         NSArray *arr = @[@"jack",@"rose",@"lili"];
         注意:  这种创建方式 不需要在最后加nil.
 
 
 
   4. NSArray数组的使用.
 
      1). 在NSLog函数中使用%@可以直接输出NSArray对象中的所有的元素的值.
 
      2). NSArray数组中不能存储基本数据类型.不能存储非OC对象.
          nil的本质其实就是0 所以nil无法存储到NSArray数组中.
 
      3). 这样创建数组没有任何意义.
             NSArray *arr1 = [NSArray new];
             NSArray *arr2 = [[NSArray alloc] init];
             NSArray *arr3 = [NSArray array];
          这些数组是没有元素的 而NSArray数组元素无法新增和删除,所以没有任何意义.
    
  5. 取出存储在NSArray数组中的元素的值.
 
     1). 可以使用下标取出对应的元素的值.
 
         NSArray *arr = @[@"jack",@"rose",@"lili"];
         
         NSLog(@"%@",arr[0]);
         NSLog(@"%@",arr[1]);
         NSLog(@"%@",arr[2]);
 
         如果下标越界 就直接运行报错.
 
 
     2). 调用数组对象的对象方法来取出指定下标的元素的值.
 
        - (ObjectType)objectAtIndex:(NSUInteger)index;
 
    
         NSArray *arr = @[@"jack",@"rose",@"lili"];
         NSString *str = [arr objectAtIndex:3];
         NSLog(@"%@",str);
         
 
 
  6. NSArray数组的其他的常用方法
 
     1). 得到NSArray数组中的元素的个数.
 
         @property (readonly) NSUInteger count;
 
     2). 判断NSArray数组中是否包含指定的元素.
 
         - (BOOL)containsObject:(ObjectType)anObject;
 
 
     3). 取到NSArray数组中的第1个元素.
         @property (nullable, nonatomic, readonly) ObjectType firstObject
 
         与arr[0]的区别.
         如果数组中没有任何元素.arr[0]报错. firstObject取到nil 不报错.
 
     4). 取到NSArray数组中的最后1个元素.
         @property (nullable, nonatomic, readonly) ObjectType lastObject
 
     5). 查找指定的元素在NSArray数组中第一次出现的下标.
         - (NSUInteger)indexOfObject:(ObjectType)anObject;
 
         如果没有找到 返回的是NSUInteger的最大值.
 
 
  7. NSArray数组的遍历.
 
     1). 使用for循环来遍历数组中的每1个元素.
 
         NSArray *arr = @[@"jack",@"rose",@"lili",@"jack",@"rose",@"lili"];
         
         for(int i = 0; i < arr.count; i++)
         {
             //NSLog(@"%@",arr[i]);
             NSLog(@"%@",[arr objectAtIndex:i]);
         }
 
         原理: 将下标挨个挨个遍历出来 取值.
 
 
     2). 使用增强for循环来遍历NSArray数组中的元素.
         
         a. 语法格式:
            for(元素类型 变量名 in 数组名)
            {
                直接通过变量名就可以拿到数组中的每1个元素.
            }
 
         b. 声明在for()中的变量叫做迭代变量.
 
         c. 执行的原理.  
 
            将数组中的第1个元素的值赋值给迭代变量.执行循环体.   
            将数组中的第2个元素的值赋值给迭代变量.执行循环体. 
            将数组中的第3个元素的值赋值给迭代变量.执行循环体.   
            .......
            将数组中的最后1个元素的值赋值给迭代变量.执行循环体.   
            结束循环.
 
 
         d. 语法总结:
            -> 迭代变量的类型和数组中的元素的类型保持一致.
            -> 迭代变量的名称可以任意取,根据自己的爱好.
            -> in是固定的.
            -> 遍历那1个数组,就降数组写在in后面.
            -> 循环体里面.迭代变量的值就是元素的值.
 
 
          当NSArray数组中存储的数据的类型不一致时候 迭代变量的类型建议使用id类型.
 
 
     3). 使用block遍历.
 
         - (void)enumerateObjectsUsingBlock:(void (^)(ObjectType obj, NSUInteger idx, BOOL *stop))block
 
         这是1个方法.这个方法的作用就是来遍历数组中的每1个元素.
 
 
 
 
  8. NSArray与字符串的两个方法
 
     1). 将数组中的元素连接起来组成1个新的字符串.
 
         - (NSString *)componentsJoinedByString:(NSString *)separator
 
         参数: 连接符.
 
 
     2). 将字符串以指定的分隔符分成1个数组. 每1部分就是数组的1个元素.      
         - (NSArray<NSString *> *)componentsSeparatedByString:(NSString *)separator;

----------------------------------华丽的分割线--------------------------- 
1. 非常重要的问题
        
     %p : 打印的是指针变量的值.
     %@ : 打印的是指针变量指向的对象.
 
 
  2. 使用NSLog函数 %@ 打印对象的原理.
 
     1). 调用传入的对象的description方法.
 
         description是定义在NSObject协议中的1个方法.因为NSObject类遵守了NSObject协议.
         所以,NSObject类中就有这个description方法的实现.
         所以.所有的OC对象中都有description方法
 
         这个方法的返回值是NSString字符串.
 
 
     2). 取到description方法的返回值,然后输出返回值的内容.
 
 
 
     3)  description方法是NSObject类中实现的.
 
         在NSObject类中的description方法是如何实现的呢?
         实现: 返回如下格式的字符串
              @"<对象所属的类名:对象的地址>"
 
 
     4). 如果我们自定义的类不想打印NSObject中description方法的返回值.
         而是我自己定义的额.
 
         这个时候只需要子类重写父类的description方法

----------------------------------华丽的分割线--------------------------- 
 1. NSMutableArray是NSArray的子类.
 
     1). NSMutableArray仍然是1个数组.具备NSArray数组的特点.
         只能存储OC对象.每1个元素的紧密相连的.
 
     2). NSMutableArray相对于父类做的扩展:NSMutableArray数组的元素可以动态的新增和删掉.
         其他的用法均与NSArray一致.
 
         所以: NSArray数组一旦创建,其元素的个数就固定,无法新增删除.
              NSMutableArray数组.元素可以新增 可以删除. 其他用法和父类一样.
 
 
 
  2.NSMutableArray数组的创建.
 
     NSMutableArray *arr1 = [NSMutableArray new];
     NSMutableArray *arr2 = [[NSMutableArray alloc] init];
     NSMutableArray *arr3 = [NSMutableArray array];
 
     这样创建出来的数组对象.数组的元素是0 仍然是有意义的 因为我们可以动态的新增和删除元素.
 
 
 
     也可以使用这样的方式来创建可变数组对象.这个数组的元素可以新增和删除.
     NSMutableArray *arr4 = [NSMutableArray arrayWithObjects:@"jack",@"rose",@"lili", nil];
 
 
     最容易犯错:这样写是不可以的
     NSMutableArray *arr5 = @[@"jack",@"rose",@"lili"];
 
     @[@"jack",@"rose",@"lili"];这是1个NSArray对象.
     arr5是1个子类指针. 子类指针指向父类对象的就有可能会出问题.

 
 ---------插入---------
 
 1. 任意的指针其实可以指向任意的对象.  编译不会报错 只会给1个警告.
 
 2. 虽然语法上可以乱指.但是你千万别乱指.因为运行的适合可能出错.
 
    当我们调用指针类型特有的方法的时候.
 
 -------------------------
 
 
 3.  如何往可变数组中新增元素.
 
     - (void)addObject:(ObjectType)anObject; 将传入的参数作为数组的元素添加进去.
 
 
 4.  将另外1个数组中的每1个元素添加到可变数组中.
 
     - (void)addObjectsFromArray:(NSArray<ObjectType> *)otherArray;
 
 
 5. 在可变数组中指定的下标出插入1个元素.
 
    - (void)insertObject:(ObjectType)anObject atIndex:(NSUInteger)index;
 
 
 --------------
 
 6. 删除可变数组中指定下标的元素.
 
    - (void)removeObjectAtIndex:(NSUInteger)index;
 
 7. 删除可变数组中所有的指定的元素.
 
    - (void)removeObject:(ObjectType)anObject;
 
 8. 删除指定范围中的所有指定元素.
 
    - (void)removeObject:(ObjectType)anObject inRange:(NSRange)range;
 
 9. 删除最后1个元素
     
    - (void)removeLastObject;
 
 10.删除所有的元素.
 
    - (void)removeAllObjects;

----------------------------------华丽的分割线--------------------------- 
 1. 无论是NSArray还是NSMutbaleArray里面都只能存储OC对象.
     基本数据类型是无法存储的.
 
  
  2. 如何将基本数据类型的数据存储到NSArray数组中.
 
 
  3. 自定义包装类来包装基本数据类型.
 
     定义1个类,这个类的对象的作用是用来存储1个int类型的数据.再将这个对象存储到NSArray数组中.
 
 
 
 
  4. NSNumber是Foundation框架中定义好的1个类.这个类的对象的作用就是用来包装基本数据类型的.
     
     将基本数据类型存储到NSArray数组中的步骤.
 
     1). 先讲基本数据类型包装到NSNumber对象中.
     2). 再降NSNumber对象存储到NSArray数组中.
 
 
     NSNumber *number1 = [NSNumber numberWithFloat:10.1f];
     NSNumber *number2 = [NSNumber numberWithFloat:10.2f];
     NSNumber *number3 = [NSNumber numberWithFloat:10.3f];
     
     NSArray *arr = @[number1,number2,number3];
     for(NSNumber *num in arr)
     {
            NSLog(@"%f",num.floatValue);
     }
 
 
  5. 简写方式.
 
     创建NSNumber对象的简写方式:
 
 
     @10;  代表是1个NSNumber对象.这个对象中包装的是整形的10
           这个不是整形的10
     [NSNumber numberWithInt:10];
 
 
     包装注意:
 
     如果后面的数据是1个变量 那么这个变量就必须要使用小括弧括起来.
 
     @(10);
 
     int num = 10;
     @(num)

----------------------------------华丽的分割线--------------------------- 
1. NSString类
 
     1). NSString的本质是1个类.
     2). @"jack"; 是1个NSString对象.
     3). 字符串的恒定性.
     4). 最常用的5个方法. 
     5). 其他方法.
 
  2. NSMutableString
 
     1). 是NSString的子类.
     2). 可变.
     3). 使用场景. 大批量的字符串拼接的时候.
 
  3. NSArray
     1). 数组.
     2). 特点
     3). 创建 取出 遍历 其他的常用.
 
  4. NSMutableArray
     1). 是NSArray的子类.
 
     2). 元素可以新增和删除.
 
 
  5. NSNumber
 
----------------------------------华丽的分割线--------------------------- 
 
  1. 将数组的信息(数组的元素的值)保存起来.保存在磁盘上.
     数据持久化.
 
 
 
  2. plist文件.属性列表文件.
     这个文件可以保存数组. 把数组中的元素保存在这个文件中.
 
 
  3. 原理:
     1). 将数组的信息存储到plist文件中. 就会将数组的所有的元素存储到这个文件中.
 
     - (BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFile;
 
 
     2). 将plist文件中的数据还原为1个数组.
    
     + (nullable NSArray<ObjectType> *)arrayWithContentsOfFile:(NSString *)path;

----------------------------------华丽的分割线--------------------------- 
 1. NSArray与NSMutableArray 是OC中的数组.
     存储数据的特点:  每1个元素紧密相连.并且每1个元素中都是直接存储的值.
     缺点: 数组元素的下标不固定.都有可能会发生变化.无法通过下标来唯一确定数组中的元素.
 
     希望: 有一种存储数据的方式 存储到数组中.可以快速唯一的确定数组的元素.
 
     存储数据的时候.必须要为存储的数据取1个别名.
     这个别名的作用: 就是用来确定别名对应的数据的.
     要找存储在数组中的数据. 使用别名来找 而不是通过下标来找 因为下标有可能会发生变化.
 
     这种存储数据的方式 就叫做 键值对 的存储方式
 
     Key-Value
     Key 就是键 就是为数据取得别名.
     Value 就是值 就是真正存储的数据.
 
 
  2. NSDictionary 与 NSMutableDictionary
 
     1). 它们是数组. 它们就是以键值对的形式存储数据的.
         往这个数组中存储数据的同时.必须要指定这个数据的别名才可以.
         要找到存储在这个数组中的数据 通过别名来找 而不是通过下标.
 
 
     
  3. NSDictionary 字典数组
 
     1). 存储数据的原理.
         a. 以键值对的形式存储数据.
         b. 字典数组一旦创建,其中的元素就无法动态的新增和删除.
         c. 键: 只能是遵守了NSCoping协议的对象. 而NSString就是遵守了这个协议.
            值: 只能是OC对象.
 
     2). 创建字典数组
 
         NSDictionary *dict1 = [NSDictionary new];
         NSDictionary *dict2 = [[NSDictionary alloc] init];
         NSDictionary *dict3 = [NSDictionary dictionary];
 
         这种方式创建出来的字典数组中没有任何元素.所以没有意义.
 
     3). 一般创建方式
 
         + (instancetype)dictionaryWithObjectsAndKeys:(id)firstObject, ...
 
         将字典数组的值键 挨个的写在后面初始化.
 
         NSDictionary *dict = [NSDictionary dictionaryWithObjectsAndKeys:@"jack",@"name",@"北京市XX街道",@"address", nil];
 
 
     4). 简要创建方式.
            
         NSDictionary *dict = @{键1:值1,键2:值2,键3:值3,........};
          
         NSDictionary *dict = @{@"name":@"rose",@"age":@"18",@"addredd":@"BeiJingXXSttreet"};
 
 
 
  4. 使用字典数组.
 
     1). 如何取出存储在字典数组中的数据.
         a. 存储在字典数组中的元素不能使用下标去取 而是用键 也就是别名去取.
 
         -> 使用中括弧的方式.
            字典数组名[键]; 这样就可以去到字典数组中这个键对应的值.
 
            NSLog(@"%@",dict[@"name"]); 取出dict字典数组中@"name"这个键对应的值.
 
 
         -> 调用字典数组对象的方法也可以取出键对应的值.
 
           - (nullable ObjectType)objectForKey:(KeyType)aKey;
 
        如果给定的key在数组中不存在,取到的值是nil 不会报错.
 
 
     2). 取到字典数组的键值对的个数.
 
         @property (readonly) NSUInteger count;
 
 
     3). 往字典数组中存储键值对的时候 键不允许重复.

         如果键重复: 后加的无效.. ???????????????
             

 
  5. 遍历字典数组
 
 
     1). 字典数组中的数据无法使用下标去取 所以普通的for循环遍历下标发就无用武之地了.
 
     2). 使用for in循环. 遍历出来的是字典数组中所有的键. 再通过键取出对应的值.
 
         NSDictionary *dict = @{
                 @"name":@"rose",
                 @"age":@"18",
                 @"address":@"BeiJingXXSttreet"
         };
         
         
         for(id item in dict)
         {
                NSLog(@"%@ = %@",item,dict[item]);
         }
 
    3). 使用block遍历.
         
 
         [dict enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {
         
                NSLog(@"%@ = %@",key,obj);
         
         }];
 
 
 
  6. 字典数组存储数据的原理.
 
     1). 当往字典数组中存储1个键值对的时候,这个键值对应该存储在下标为几的元素中呢?
         -> 并不是按照顺序挨个挨个的存储的.
 
         -> 存储键值对的时候,会根据键和数组的长度做1个哈希算法.算出1个下标.将这个键值对存储在该下标处.
 
 
     2). 取值的时候:
         也是根据键做1个哈希算法.就可以算出这个键值对存储的下标 然后直接找到这个下标的数据取出就可以了.
 
 
 
     与NSArray对比
 
     1). NSArray数组的元素 挨个挨个的屁股后面. 按照顺序来存储的.
         字典数组中不是挨个挨个的存储的.存储的下标是算出来的.
 
 
     2). 存的效率: 肯定是NSArray要高一些.
         取得时候: 如果取值的时候,是全部一股脑的取出来.这个时候NSArray块一些.
                  如果取值的时候.只会取数组中指定的几个元素.字典数组取值更快一些.
         
 
 
    什么时候是有NSArray 什么时候使用字典数组?
 
    存储进去之后,一旦要取值.就是全部取出. NSArray
    存储进去之后.取值只会取指定的几个元素 字典数组.
 
----------------------------------华丽的分割线--------------------------- 
 
 
 1. NSMutableDictionary
 
    1). 是NSDictionary的子类.所以NSMutableDictionary也是1个字典数组,也是以键值对的形式存储数据的.
 
    2). 重点:NSMutableDictionary在父类基础之上做的扩张:
 
        存储在其中的元素可以动态的新增和删除.
 
    3). 创建可变字典数组.
         NSMutableDictionary *dict1 = [NSMutableDictionary new];
         NSMutableDictionary *dict2 = [[NSMutableDictionary alloc] init];
         NSMutableDictionary *dict3 = [NSMutableDictionary dictionary];
         
         这样创建出来的可变字典数组的长度为0 但是有意义 因为可以动态的新增和删除.
 
 
         NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithObjectsAndKeys:@"jack",@"name",@"18",@"age", nil];
         在创建可变字典数组的同时初始化键值对.
 
         注意:  NSMutableDictionary *dict = @{}; 这样是不行的.
 
 
 2. 如何新增键值对.
 
    - (void)setObject:(ObjectType)anObject forKey:(KeyType <NSCopying>)aKey;
 
    如果键重复.后添加的就会替换原有的.
 
 3. 如何删除.
 
    - (void)removeAllObjects; 删除所有的键值对.
 
    - (void)removeObjectForKey:(KeyType)aKey; 删除指定的键值对.
 
 
 4. 也可以将字典数组的信息持久化起来.
 
    将字典数组的信息保存到plist文件中.
    - (BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFile;

    从plist文件中还原回字典.
    + (nullable NSDictionary<KeyType, ObjectType> *)dictionaryWithContentsOfFile:(NSString *)path;

----------------------------------华丽的分割线--------------------------- 
 1. 集合
     NSArray集合、NSDictionary字典集合 就叫做集合.
 
 
  2. 在MRC的模式下 将1个对象存储到集合中,会不会影响对象的引用计数器.
 
     将对象存储到集合之中,会为这个对象的引用计数器+1
     当集合销毁的时候 就会像存储在集合中的所有的对象发送1条release消息.
 
    
  3. 使用@[]或者@{}创建的集合已经是被autorelease过的了.     
     直接调用和类同名的类方法创建的对象 也是被autorelease过的了.
 

  4. 在ARC的模式下.集合的元素是1个强类型的指针.

----------------------------------华丽的分割线--------------------------- 
1. NSFileManger是Foundation框架提供的1个类.   
     这个类作用: 用来操作磁盘上的文件 文件夹  对他们进行创建、删除、复制 拷贝 移动.....
 
  2. NSFileManager是1个类.
     这个类的对象是以单例模式创建的.
     如何得到NSFileManager的1个单例对象.
     掉用这个类的类方法,defaultManager 就可以得到这个类的单例对象
     NSFileManager *fileManager = [NSFileManager defaultManager];
 
  3. 常用方法之 判断.
     1). 判断指定的文件或者文件夹在磁盘上是否真实的存在
        - (BOOL)fileExistsAtPath:(NSString *)path;
 
     2).判断指定的路径是否真实的存储在我们的磁盘之上,并且判断这个路径是1个文件夹路径还是1个文件路径.
        - (BOOL)fileExistsAtPath:(NSString *)path isDirectory:(BOOL *)isDirectory;
        返回值:代表这个路径是否真实存在.
        参数指针: 代表这个路径是否是1个文件夹路径
     
     3). 判断指定的文件夹或者文件是否可以读取.
         - (BOOL)isReadableFileAtPath:(NSString *)path;
 
     4). 判断指定的文件夹或者文件是否可以写入.
         - (BOOL)isWritableFileAtPath:(NSString *)path;
 
     5). 判断指定的文件夹或者文件是否可以删除.
         - (BOOL)isDeletableFileAtPath:(NSString *)path
 
 4. 常见方法之 获取信息.
    1).获取指定文件或者文件夹的属性信息.
       - (NSDictionary *)attributesOfItemAtPath:(NSString *)path error:(NSError **)error
       返回的是1个字典,如果要拿到特定的信息 通过key
 
    2).获取指定目录下的所有的文件和目录. 是拿到指定目录下的所有的文件和目录 所有的后代目录和文件.
       子目录的子目录的子目录 所有的都可以拿到.
       - (NSArray *)subpathsAtPath:(NSString *)path;
 
    3).获取指定目录下的所有的子目录和文件 不保护孙子辈.
       - (NSArray *)contentsOfDirectoryAtPath:(NSString *)path error:(NSError **)error
 
 5. 常见方法之 文件/目录的创建
    
    1). 在指定的目录创建文件.
        - (BOOL)createFileAtPath:(NSString *)path contents:(NSData *)data attributes:(NSDictionary *)attr
        第1个参数: 要创建的文件的路径.
        第2个参数: 这个文件的内容.  要传递这个文件的二进制格式. 
                  这个二进制的数据格式 使用NSData对象来封装.
 
                  NSData: 将别的格式的数据转换为二进制数据.
    
                  将字符串转换为NSData二进制的方式.调用字符串对象的
                   - (NSData *)dataUsingEncoding:(NSStringEncoding)encoding
                   编码参数: NSUTF8StringEncoding
                  指定1个编码 就可以将字符串转换为二进制数据 存储在NSData对象之中.
 
                  最后再将这个二进制对象通过这个方法写入.
 
                  如果想创建1个空文件 第2个参数就给nil
 
        第3个参数: 指定创建的文件的属性.如果想要使用系统的默认值使用nil
 
    2). 在指定的目录创建文件夹.
        - (BOOL)createDirectoryAtPath:(NSString *)path withIntermediateDirectories:(BOOL)createIntermediates attributes:(NSDictionary *)attributes error:(NSError **)error
 
        第1个参数: 路径.
        第2个参数: YES,做一路创建. 如果是NO就不会做一路创建.
        第3个参数: 指定属性 nil为系统默认属性.
        第4个参数.
 
    3).拷贝文件.
       - (BOOL)copyItemAtPath:(NSString *)srcPath toPath:(NSString *)dstPath error:(NSError **)error
    
    4).移动文件 剪切 文件的重命名. 重名的原理: 将文件移动到原来的目录并改名.
       - (BOOL)moveItemAtPath:(NSString *)srcPath toPath:(NSString *)dstPath error:(NSError **)error
 
    5).删除文件.
       - (BOOL)removeItemAtPath:(NSString *)path error:(NSError **)error
 
      注意 删除的文件不会倒废纸篓 而是直接删除,所以请小心使用.

----------------------------------华丽的分割线--------------------------- 
1. 定义1个变量来保存按钮在iOS界面上得位置.
     
     我们定义1个结构体来表示控件在界面上得坐标.
 
     typedef struct
     {
        int x;
        int y;
     }CZPoint;
 
  
     CZPoint p1 = {20,30};
 
 
     在Foundation框架中,已经定义了1个结构体CGPoint.
 
     struct CGPoint {
        CGFloat x;
        CGFloat y;
     };
     typedef struct CGPoint CGPoint;
 
     CGFloat类型的实际上就是1个double类型的.
 
 
     这个结构体一般情况下是用来表示坐标的. 用来表示控件在界面上得位置.
     CGPoint与NSPoint都是同1个结构体,只不过定义两个名字.
     typedef CGPoint NSPoint;
 
 
     ---------声明CGPoint变量并初始化的方式-------
     1). CGPoint p1;
         p1.x = 20;
         p1.y = 30;
 
 
     2). CGPoint p1 = {20,30};
    
     3). CGPoint p1 = {.x = 20, .y = 30};
 
 
     4). Foundation框架中提供的函数来快速的创建1个CGPoint变量.
         
         a. CGPointMake(x,y);
            CGPoint p1 =  CGPointMake(20, 30);
 
         b. NSMakePoint(x,y);
            NSPoint p2 =  NSMakePoint(20, 30);
 
 
 
   2. 声明1个变量来保存某个控件的大小.
 
      1个控件的大小,无非就是两个数据. 宽度、高度.
 
      typedef struct
      {
         double width;
         double height;
      }CZSize;
 
    
      CZSize size = {50,20};
 
 
      Foundation框架中已经定义好了1个结构体叫做CGSize;
      struct CGSize {
        CGFloat width;
        CGFloat height;
      };
      typedef struct CGSize CGSize;
 
      typedef CGSize NSSize;
      NSSize和CGSize是同1个结构体,只不过定义了两个名称.
 
      CGSize结构体一般情况下用来表示控件的大小.
 
 
      ------CGSize声明并初始化的方式----------
      1). CGSize size;
          size.width = 100;
          size.height = 30;
 
      2). CGSize size = {100,30};
 
      3). CGSize size = {.width = 100, .height = 30};
 
 
      4). Foundation框架中提供了函数用来快速的得到1个CGSize结构体变量.
        
          a. CGSizeMake(width,height);
 
             CGSize size0 =  CGSizeMake(100, 30);
 
          b. NSMakeSize(w,h);
             CGSize size1 =  NSMakeSize(100, 30);
 
 
     
  
  3. CGRect和NSRect
 
     这是定义在Foundation框架中的1个结构体.
         struct CGRect {
             CGPoint origin;
             CGSize size;
         };
         typedef struct CGRect CGRect;
 
     所以,这个结构体变量一般情况下存储1个控件的位置和大小.
 
     typedef CGRect NSRect;
 
     NSRect和CGRect是一样的.
 
     ----CGRect的声明和初始化-----
 
     1).
         CGRect rect;
         rect.origin.x = 20;
         rect.origin.y = 40;
         rect.size.width = 100;
         rect.size.height = 30;
 
         当结构体作为另外1个结构体或者对象的1个属性的时候,不能直接{}赋值.
 
         CGRect rect;
         rect.origin = (CGPoint){10,20};
         rect.size = (CGSize){100,30};
         
 
 
     2). 也提供了函数来快速的创建CGRect变量.
 
         CGRect rect =  CGRectMake(10, 20, 100, 30);
         CGRect rect1 =  NSMakeRect(10, 20, 100, 30);
         
 
    
 
  使用的时候. CGSize NSSize  建议使用CG...

----------------------------------华丽的分割线--------------------------- 
 1. 我们之前学习的结构体.
      NSRange
      CGPoint
      CGSize
      CGRect
      这些都是结构体,它们的变量是无法存储到集合之中.
 
   2. 解决方案:
    
      先将这写结构体变量存储到OC对象中,再将OC对象存储到集合之中.
 
 
   3. NSValue 类 的对象就是用来包装结构体变量的.

----------------------------------华丽的分割线--------------------------- 
 1. NSDate 时间处理.
 
    1). 可以得到当前时间. 创建1个NSDate对象就可以了,将这个对象输出,就是当前时间
        得到的是当前系统的格林威治时间. 0时区的时间. 东8区.
 
        NSDate *date = [NSDate date];
        NSLog(@"%@",date);
 
    2). 格式化输出日期. 指定日期输出的格式
        默认的格式 年-月-日 时:分:秒 +时区.
         NSDate *date = [NSDate date];
         NSLog(@"%@",date);
 
         //1.先要创建1个NSDateFormatter对象,这个对象作用:将1个日期转换成1个指定的格式.
         NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
         //2.告诉这个日期格式化器对象 要把日期转换个什么样子的.
 
         yyyy: 年份
         MM: 月份.
         mm: 分钟.
         dd: 天.
         hh: 12小时.
         HH: 24小时
         ss: 秒
 
         formatter.dateFormat = @"yyyy年MM月dd日 HH点mm分ss秒";

         //3.使用日期格式化器 将指定的日期转换指定格式的字符串.
         NSString *str =[formatter stringFromDate:date];
         NSLog(@"str = %@",str);

 
 - (NSString *)stringFromDate:(NSDate *)date; //将日期类型换换为字符串
 - (NSDate *)dateFromString:(NSString *)string;//将字符串转换为日期对象.
 
    注意: NSDate取到的时间是格林威治的时间.
         NSDateFormatter转换成字符串以后 会转换为当前系统的时区的时间.
 
 2. 计算时间.
     
    1). 想得到明天此时此刻的时间.
        当前时间的基础之上 + 1天的时间.
 
        在当前时间的基础之上,新增指定的时间.得到的1个新的时间.
 
        + (instancetype)dateWithTimeIntervalSinceNow:(NSTimeInterval)secs;
        在当前的时间的基础之上,新增指定的秒.后的时间
        得到东八区的时间:
        NSDate *d1 =[NSDate dateWithTimeIntervalSinceNow:8*60*60];
 
    
        传入1个负数 就是在当前时间的基础之上减指定的秒数.
 
 
    2). 求两个时间之间的差.
        可以实现的效果.就是可以计算出执行代码所花费的时间.
 
        - (NSTimeInterval)timeIntervalSinceDate:(NSDate *)anotherDate;
 
 
 3. 得到NSDate中的年月日时分秒.
    
    1). 得到时间的各个部分。可以使用日期格式化器来得到.
    2). 比较复杂.
 
     NSDate *date = [NSDate date];
     
     //1.创建1个日历对象. 调用类方法currentCalendar得到1个日历对象.
     NSCalendar *calendar = [NSCalendar currentCalendar];
     //2.指定日历对象取到日期的对象的那些部分. 是要取那1个时间对象的部分.
     // 返回1个日期组件对象.这个对象中就有指定日期的指定部分.
     NSDateComponents *com =  [calendar components:NSCalendarUnitYear|NSCalendarUnitMonth|NSCalendarUnitDay fromDate:date];
     
     NSLog(@"%ld-%ld-%ld",com.year,com.month,com.day);

----------------------------------华丽的分割线--------------------------- 
  1. 无论在MRC还是ARC下,如果属性的类型是NSString类型的. @property参数使用copy.
 
 
  2. copy 复制
 
     1). copy是1个方法.定义在NSObject类之中. 作用:拷贝对象.
 
         NSString ----> copy ---> 不可变字符串  没有产生新对象,而是直接将对象本身的地址返回. 这种拷贝我们叫做浅拷贝
         NSMutableString --> copy --> 是1个不可变的字符串对象 .  有产生1个新对象.这样的拷贝我们叫做深拷贝.
 
 
     2). mutableCopy.定义在NSObject类之中. 作用:拷贝对象.
 
         NSString  ---> mutableCopy --> 可变字符串对象. 深拷贝.
         NSMutableString --> mutableCopy --> 可变字符串对象 深拷贝.
 
 
     这是字符串的对象拷贝特点.
 
  3. 字符串对象拷贝的引用计数器的问题.
 
     1). 若字符串对象存储在常量区中. 存储在常量区的数据是不允许被回收的.
         所以存储在常量区的字符串对象的引用计数器是1个超大的数.并且retain和release无效.
 
     2). 若字符串存储在堆区. 这个字符串对象和普通的对象一样的.引用计数器默认是1.
 
     3). 字符串对象如果是浅拷贝. 会将对象的引用计数器+1
 
         字符串对象如果是深拷贝. 原来的对象的引用计数器不变.新拷贝出来的对象的引用计数器为1.
 

----------------------------------华丽的分割线--------------------------- 
1. copy方法的确是定义在NSObject类中的1个方法.
     copy方法的内部调用了另外1个方法. copyWithZone:
 
    
     这个方法是定义在NSCoping协议之中的.
 
 
    因为我们的类没有遵守NSCoping协议,那么我们的类中就没有 copyWithZone:这个方法.  
    所以,当我们自定义的类调用copy方法的时候就会出错/
 
 
 
 2. 如果我们想要让我们自己的类具备对象拷贝的能力.那么就让我们的类遵守NSCoping协议
    并实现copyWithZone:这个方法. 
 
    如果想要实现深拷贝:那么就重新创建1个对象.并将对象的属性的值复制.返回.
    如果想要实现浅拷贝:那么就直接返回self

----------------------------------华丽的分割线--------------------------- 
1. 单例模式:
 
     1个类的对象,无论在何时创建也无论在什么地方创建 也无论创建多少次.创建出来的都是同1个对象.
 
 
  2. 无论如何创建对象,最终都会调用alloc方法来创建对象.
     
     1). alloc方法的内部. 其实什么都没有做,只是调用了allocWithZone:方法.
 
     2). 实际上真正申请空间 创建对象的事情是allocWithZone:方法在做.
 
 
  3. 要实现单例模式.
 
     重写+ allocWithZone:
 
     + (instancetype)allocWithZone:(struct _NSZone *)zone
     {
         static id instance = nil;
         if(instance == nil)
         {
            instance = [super allocWithZone:zone];
         }
         return instance;
     }
 
 
  4. 单例模式的规范:
     如果类是1个单例模式.要求为类提供1个类方法.来返回这个单例对象.
 
 
     类方法的名称必须以 shared类名; default类名;
 
 
 
  5. 什么时候要把类搞成单例.
     1). 单例的特点
         无论何时、何地、创建对象,也不管创建多少次对象,得到都是同1个对象.
         单例对象可以被共享. 存储在单例对象中的数据可以被共享.
         也就是无论在什么地方创建单例对象 访问的都是同1个对象.
 
 
     2).
 
 
 
     做游戏:
     游戏面板的宽度: 800
     游戏面板的高度: 600
 
     这两个数据基本上在很多的地方都会使用到.
 
     1. 直接写. 滚蛋.
     2. 宏. 程序运行的时候无法更改.
     3. 还是要定义为变量.
 
     定义为属性保存在对象中. 如果不是单例对象.
 
 
 
     如果数据需要被整个程序所共享. 将数据以属性的方式存储在单例对象中.

----------------------------------华丽的分割线--------------------------- 
